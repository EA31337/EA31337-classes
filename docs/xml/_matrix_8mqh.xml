<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="_matrix_8mqh" kind="file" language="C++">
    <compoundname>Matrix.mqh</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">//+------------------------------------------------------------------+</highlight></codeline>
<codeline><highlight class="normal">//|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EA31337<sp/>framework<sp/>|</highlight></codeline>
<codeline><highlight class="normal">//|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Copyright<sp/>2016-2021,<sp/>31337<sp/>Investments<sp/>Ltd<sp/>|</highlight></codeline>
<codeline><highlight class="normal">//|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>https://github.com/EA31337<sp/>|</highlight></codeline>
<codeline><highlight class="normal">//+------------------------------------------------------------------+</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>This<sp/>file<sp/>is<sp/>free<sp/>software:<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or<sp/>modify</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>it<sp/>under<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>as<sp/>published<sp/>by</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>the<sp/>Free<sp/>Software<sp/>Foundation,<sp/>either<sp/>version<sp/>3<sp/>of<sp/>the<sp/>License,<sp/>or</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>(at<sp/>your<sp/>option)<sp/>any<sp/>later<sp/>version.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>This<sp/>program<sp/>is<sp/>distributed<sp/>in<sp/>the<sp/>hope<sp/>that<sp/>it<sp/>will<sp/>be<sp/>useful,</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>but<sp/>WITHOUT<sp/>ANY<sp/>WARRANTY;<sp/>without<sp/>even<sp/>the<sp/>implied<sp/>warranty<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>MERCHANTABILITY<sp/>or<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE.<sp/><sp/>See<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>You<sp/>should<sp/>have<sp/>received<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>along<sp/>with<sp/>this<sp/>program.<sp/><sp/>If<sp/>not,<sp/>see<sp/>&lt;http://www.gnu.org/licenses/&gt;.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Prevents<sp/>processing<sp/>this<sp/>includes<sp/>file<sp/>for<sp/>the<sp/>second<sp/>time.</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>MATRIX_MQH</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>MATRIX_MQH</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifdef<sp/>USE_MQL_MATH_STAT</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>__MQL5__</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;Math/Stat/Normal.mqh&gt;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;Math.h&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#define<sp/>MATRIX_DIMENSIONS<sp/>6</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>MATRIX_VALUES_ARRAY_INCREMENT<sp/>500</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Forward<sp/>declarations.</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MatrixDimension;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Matrix;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#define<sp/>MATRIX_STRIDE_AS_POOL<sp/>-1</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">enum<sp/>ENUM_MATRIX_VECTOR_REDUCE<sp/>{<sp/>MATRIX_VECTOR_REDUCE_COSINE_SIMILARITY,<sp/>MATRIX_VECTOR_REDUCE_HINGE_LOSS<sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Types<sp/>of<sp/>matrix<sp/>pool<sp/>padding.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>@see<sp/>https://keras.io/api/layers/pooling_layers/average_pooling2d/</highlight></codeline>
<codeline><highlight class="normal">enum<sp/>ENUM_MATRIX_PADDING<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>No<sp/>padding.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_PADDING_VALID,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Results<sp/>in<sp/>padding<sp/>evenly<sp/>to<sp/>the<sp/>left/right<sp/>or<sp/>up/down<sp/>of<sp/>the<sp/>input<sp/>such<sp/>that<sp/>output<sp/>has<sp/>the<sp/>same<sp/>height/width</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>dimension<sp/>as<sp/>the<sp/>input.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_PADDING_SAME</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Types<sp/>of<sp/>matrix<sp/>dimensions.</highlight></codeline>
<codeline><highlight class="normal">enum<sp/>ENUM_MATRIX_DIMENSION_TYPE<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_DIMENSION_TYPE_UNKNOWN,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_DIMENSION_TYPE_CONTAINERS,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_DIMENSION_TYPE_VALUES</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Matrix<sp/>operation<sp/>types.</highlight></codeline>
<codeline><highlight class="normal">enum<sp/>ENUM_MATRIX_OPERATION<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_ADD,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_SUBTRACT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_MULTIPLY,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_DIVIDE,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_ABS,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_FILL,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_FILL_RANDOM,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_FILL_RANDOM_RANGE,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_FILL_POS_ADD,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_FILL_POS_MUL,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_POWER,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_SUM,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_MIN,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_MAX,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_AVG,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_MED,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_POISSON,<sp/><sp/><sp/>//<sp/>b<sp/>-<sp/>a<sp/>*<sp/>log(b)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_LOG_COSH,<sp/><sp/>//<sp/>log((exp((b-a))<sp/>+<sp/>exp(-(b-a)))/2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_ABS_DIFF,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_ABS_DIFF_SQUARE,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_OPERATION_RELU,</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Return<sp/>minimum<sp/>value<sp/>of<sp/>double.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">double<sp/>MinOf(double<sp/>value)<sp/>{<sp/>return<sp/>-DBL_MAX;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Return<sp/>minimum<sp/>value<sp/>of<sp/>integer.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">int<sp/>MinOf(int<sp/>value)<sp/>{<sp/>return<sp/>INT_MIN;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Return<sp/>maximum<sp/>value<sp/>of<sp/>double.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">double<sp/>MaxOf(double<sp/>value)<sp/>{<sp/>return<sp/>DBL_MAX;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Return<sp/>minimum<sp/>value<sp/>of<sp/>integer.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">int<sp/>MaxOf(int<sp/>value)<sp/>{<sp/>return<sp/>INT_MAX;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Matrix&apos;s<sp/>dimension<sp/>accessor.<sp/>Used<sp/>by<sp/>matrix&apos;s<sp/>index<sp/>operator.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>MatrixDimensionAccessor<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Pointer<sp/>to<sp/>matrix<sp/>instance.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>ptr_matrix;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Pointer<sp/>to<sp/>matrix&apos;s<sp/>dimension<sp/>instance.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MatrixDimension&lt;X&gt;*<sp/>ptr_dimension;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Index<sp/>of<sp/>container<sp/>or<sp/>value<sp/>pointed<sp/>by<sp/>accessor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>index;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MatrixDimensionAccessor(Matrix&lt;X&gt;*<sp/>_ptr_matrix<sp/>=<sp/>NULL,<sp/>MatrixDimension&lt;X&gt;*<sp/>_ptr_dimension<sp/>=<sp/>NULL,<sp/>int<sp/>_index<sp/>=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>ptr_matrix(_ptr_matrix),<sp/>ptr_dimension(_ptr_dimension),<sp/>index(_index)<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Index<sp/>operator.<sp/>Returns<sp/>container<sp/>or<sp/>value<sp/>accessor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MatrixDimensionAccessor&lt;X&gt;<sp/>operator[](int<sp/>_index)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>MatrixDimensionAccessor(ptr_matrix,<sp/>ptr_dimension.containers[index],<sp/>_index);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>target<sp/>dimension<sp/>type.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ENUM_MATRIX_DIMENSION_TYPE<sp/>Type()<sp/>const<sp/>{<sp/>return<sp/>ptr_dimension.type;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#define<sp/>MATRIX_ACCESSOR_OPERATOR(OP)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator<sp/>OP(X<sp/>_value)<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_dimension.type<sp/>!=<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Error:<sp/>Trying<sp/>to<sp/>use<sp/>matrix&quot;,<sp/>ptr_matrix.Repr(),<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;&apos;s<sp/>value<sp/>operator<sp/>&quot;<sp/>#OP<sp/>&quot;<sp/>in<sp/>a<sp/>dimension<sp/>which<sp/>doesn&apos;t<sp/>contain<sp/>values!&quot;);<sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ptr_dimension.values[index]<sp/>OP<sp/>_value;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_ACCESSOR_OPERATOR(+=)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_ACCESSOR_OPERATOR(-=)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_ACCESSOR_OPERATOR(*=)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MATRIX_ACCESSOR_OPERATOR(/=)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Assignment<sp/>operator.<sp/>Sets<sp/>value<sp/>for<sp/>this<sp/>dimensions.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator=(X<sp/>_value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_dimension.type<sp/>!=<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Error:<sp/>Trying<sp/>to<sp/>set<sp/>matrix&quot;,<sp/>ptr_matrix.Repr(),<sp/>&quot;&apos;s<sp/>value<sp/>in<sp/>a<sp/>dimension<sp/>which<sp/>doesn&apos;t<sp/>contain<sp/>values!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ptr_dimension.values[index]<sp/>=<sp/>_value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>value<sp/>pointed<sp/>by<sp/>this<sp/>accessor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>Val()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_dimension.type<sp/>!=<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Error:<sp/>Trying<sp/>to<sp/>get<sp/>value<sp/>from<sp/>matrix&quot;,<sp/>ptr_matrix.Repr(),<sp/>&quot;&apos;s<sp/>dimension<sp/>which<sp/>doesn&apos;t<sp/>contain<sp/>values!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(X)EMPTY_VALUE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>ptr_dimension.values[index];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>value<sp/>pointed<sp/>by<sp/>this<sp/>accessor<sp/>or<sp/>first<sp/>value<sp/>if<sp/>it<sp/>holds<sp/>only<sp/>one<sp/>value<sp/>or<sp/>zero<sp/>if<sp/>index<sp/>is<sp/>above<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>dimension<sp/>length.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>ValOrZero()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_dimension.type<sp/>!=<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Error:<sp/>Trying<sp/>to<sp/>get<sp/>value<sp/>from<sp/>matrix&quot;,<sp/>ptr_matrix.Repr(),<sp/>&quot;&apos;s<sp/>dimension<sp/>which<sp/>doesn&apos;t<sp/>contain<sp/>values!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(X)EMPTY_VALUE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_num_values<sp/>=<sp/>ArraySize(ptr_dimension.values);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_num_values<sp/>==<sp/>0<sp/>||<sp/>index<sp/>&gt;=<sp/>_num_values)<sp/>return<sp/>(X)0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>ptr_dimension.values[index];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>A<sp/>single<sp/>matrix&apos;s<sp/>dimension.<sp/>Contains<sp/>array<sp/>of<sp/>containers<sp/>or<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>MatrixDimension<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ENUM_MATRIX_DIMENSION_TYPE<sp/>type;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Values<sp/>array<sp/>if<sp/>type<sp/>is<sp/>&quot;Values&quot;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>values[];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Physical<sp/>position<sp/>of<sp/>the<sp/>dimension<sp/>in<sp/>the<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>position[MATRIX_DIMENSIONS<sp/>-<sp/>1];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Containers<sp/>array<sp/>if<sp/>type<sp/>is<sp/>&quot;Containers&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MatrixDimension&lt;X&gt;*<sp/>containers[];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MatrixDimension(ENUM_MATRIX_DIMENSION_TYPE<sp/>_type<sp/>=<sp/>MATRIX_DIMENSION_TYPE_UNKNOWN)<sp/>{<sp/>type<sp/>=<sp/>_type;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Destructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>~MatrixDimension()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>delete<sp/>containers[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Makes<sp/>a<sp/>clone<sp/>of<sp/>this<sp/>and<sp/>child<sp/>dimensions.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MatrixDimension&lt;X&gt;*<sp/>Clone()<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MatrixDimension&lt;X&gt;*<sp/>_clone<sp/>=<sp/>new<sp/>MatrixDimension&lt;X&gt;(type);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ArrayResize(_clone.containers,<sp/>ArraySize(containers));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_clone.containers[i]<sp/>=<sp/>containers[i].Clone();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ArrayCopy(_clone.values,<sp/>values);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_clone;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Adds<sp/>container<sp/>to<sp/>the<sp/>list.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>AddContainer(MatrixDimension*<sp/>_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ArrayResize(containers,<sp/>ArraySize(containers)<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>containers[ArraySize(containers)<sp/>-<sp/>1]<sp/>=<sp/>_dimension;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Adds<sp/>value<sp/>to<sp/>the<sp/>list.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>AddValue(X<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ArrayResize(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values,<sp/>ArraySize(values)<sp/>+<sp/>1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(ArraySize(values)<sp/>-<sp/>ArraySize(values)<sp/>%<sp/>MATRIX_VALUES_ARRAY_INCREMENT)<sp/>+<sp/>MATRIX_VALUES_ARRAY_INCREMENT);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>values[ArraySize(values)<sp/>-<sp/>1]<sp/>=<sp/>value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Sets<sp/>physical<sp/>position<sp/>of<sp/>the<sp/>dimension<sp/>in<sp/>the<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>SetPosition(int&amp;<sp/>_position[],<sp/>int<sp/>_level)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(_position);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>position[i]<sp/>=<sp/>i<sp/>&lt;<sp/>_level<sp/>?<sp/>_position[i]<sp/>:<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>string<sp/>Spaces(int<sp/>_num)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>string<sp/>_padding;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>StringInit(_padding,<sp/>_num,<sp/>&apos;<sp/>&apos;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_padding;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>string<sp/>ToString(bool<sp/>_whitespaces<sp/>=<sp/>false,<sp/>int<sp/>_precision<sp/>=<sp/>3,<sp/>int<sp/>level<sp/>=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>string<sp/>out<sp/>=<sp/>&quot;&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ArraySize(containers)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>+=<sp/>(_whitespaces<sp/>?<sp/>Spaces((level<sp/>-<sp/>1)<sp/>*<sp/>2)<sp/>:<sp/>&quot;&quot;)<sp/>+<sp/>(_whitespaces<sp/>?<sp/>&quot;[\n&quot;<sp/>:<sp/>&quot;[&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>+=<sp/>containers[i].ToString(_whitespaces,<sp/>_precision,<sp/>level<sp/>+<sp/>1)<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(i<sp/>!=<sp/>ArraySize(containers)<sp/>-<sp/>1<sp/>?<sp/>&quot;,&quot;<sp/>:<sp/>&quot;&quot;)<sp/>+<sp/>(_whitespaces<sp/>?<sp/>&quot;\n&quot;<sp/>:<sp/>&quot;&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>+=<sp/>(_whitespaces<sp/>?<sp/>Spaces((level<sp/>-<sp/>1)<sp/>*<sp/>2)<sp/>:<sp/>&quot;&quot;)<sp/>+<sp/>&quot;]&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>+=<sp/>(_whitespaces<sp/>?<sp/>Spaces(level<sp/>*<sp/>2)<sp/>:<sp/>&quot;&quot;)<sp/>+<sp/>(_whitespaces<sp/>?<sp/>&quot;[<sp/>&quot;<sp/>:<sp/>&quot;[&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(values);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(values[i]<sp/>&gt;<sp/>-DBL_MAX<sp/>&amp;&amp;<sp/>values[i]<sp/>&lt;<sp/>DBL_MAX)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>+=<sp/>DoubleToString((double)values[i],<sp/>_precision);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>+=<sp/>(values[i]<sp/>&lt;<sp/>0<sp/>?<sp/>&quot;-inf&quot;<sp/>:<sp/>&quot;inf&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>+=<sp/>(i<sp/>!=<sp/>ArraySize(values)<sp/>-<sp/>1)<sp/>?<sp/>(_whitespaces<sp/>?<sp/>&quot;,<sp/>&quot;<sp/>:<sp/>&quot;,&quot;)<sp/>:<sp/>&quot;&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>+=<sp/>(_whitespaces<sp/>?<sp/>&quot;<sp/>]&quot;<sp/>:<sp/>&quot;]&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>out;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Reduces<sp/>dimension<sp/>if<sp/>it<sp/>contains<sp/>values.<sp/>Goes<sp/>recursively<sp/>up<sp/>to<sp/>_level.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>ReduceSimple(int<sp/>_level<sp/>=<sp/>0,<sp/>ENUM_MATRIX_OPERATION<sp/>_reduce_op<sp/>=<sp/>MATRIX_OPERATION_SUM,<sp/>int<sp/>_current_level<sp/>=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS<sp/>&amp;&amp;<sp/>_current_level<sp/>&lt;=<sp/>_level)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>containers[i].ReduceSimple(_level,<sp/>_reduce_op,<sp/>_current_level<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS<sp/>&amp;&amp;<sp/>ArraySize(containers)<sp/>&gt;<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>containers[0].type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES<sp/>&amp;&amp;<sp/>ArraySize(containers[0].values)<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>MATRIX_DIMENSION_TYPE_VALUES;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X<sp/>_sum<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>ArraySize(containers[i].values);<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_sum<sp/>+=<sp/>containers[i].values[k];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AddValue(_sum);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delete<sp/>containers[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ArrayResize(containers,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Reduces<sp/>(aggregates)<sp/>dimensions<sp/>up<sp/>to<sp/>_level.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Reduce(int<sp/>_level<sp/>=<sp/>0,<sp/>ENUM_MATRIX_OPERATION<sp/>_reduce_op<sp/>=<sp/>MATRIX_OPERATION_SUM,<sp/>int<sp/>_current_level<sp/>=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS<sp/>&amp;&amp;<sp/>_current_level<sp/>&lt;<sp/>_level)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>containers[i].Reduce(_level,<sp/>_reduce_op,<sp/>_current_level<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS<sp/>&amp;&amp;<sp/>_current_level<sp/>&gt;=<sp/>_level)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>There<sp/>will<sp/>be<sp/>as<sp/>many<sp/>values<sp/>as<sp/>containers.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ArrayResize(values,<sp/>ArraySize(containers));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X<sp/>_sum<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X<sp/>_out1<sp/>=<sp/>0,<sp/>_out2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>_out3;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>containers[i].Op(_reduce_op,<sp/>0,<sp/>0,<sp/>0,<sp/>_out1,<sp/>_out2,<sp/>_out3);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>=<sp/>_out1;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delete<sp/>containers[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ArrayResize(containers,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>MATRIX_DIMENSION_TYPE_VALUES;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Reduces<sp/>dimension<sp/>if<sp/>it<sp/>contains<sp/>values.<sp/>Goes<sp/>recursively<sp/>up<sp/>to<sp/>_level.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>initial<sp/>dimensions<sp/>size<sp/>for<sp/>the<sp/>given<sp/>level.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>DuplicateDimension(int<sp/>_level,<sp/>int<sp/>_num,<sp/>int<sp/>_current_level<sp/>=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i,<sp/>k,<sp/>num_initial_containers<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS<sp/>&amp;&amp;<sp/>_current_level<sp/>&lt;<sp/>_level)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_initial_containers<sp/>=<sp/>containers[i].DuplicateDimension(_level,<sp/>_num,<sp/>_current_level<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>num_initial_containers;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>num_initial_containers<sp/>=<sp/>ArraySize(containers);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>_num;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>num_initial_containers;<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MatrixDimension&lt;X&gt;*<sp/>_new_dim<sp/>=<sp/>containers[k].Clone();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AddContainer(_new_dim);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>num_initial_containers;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Initializes<sp/>dimension<sp/>data<sp/>from<sp/>another<sp/>dimension.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>CopyFrom(MatrixDimension&lt;X&gt;&amp;<sp/>_r)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>containers[i].CopyFrom(_r.containers[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ArrayCopy(values,<sp/>_r.values);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Resizes<sp/>this<sp/>dimension<sp/>and<sp/>sets<sp/>its<sp/>type<sp/>(containers<sp/>or<sp/>values<sp/>array).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>virtual<sp/>void<sp/>Resize(int<sp/>_num_items,<sp/>ENUM_MATRIX_DIMENSION_TYPE<sp/>_type<sp/>=<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i,<sp/>_last_size;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_type<sp/>!=<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Removing<sp/>containers<sp/>if<sp/>there&apos;s<sp/>any.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delete<sp/>containers[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ArrayResize(containers,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_type<sp/>!=<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Removing<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ArrayResize(values,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(_type)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>There<sp/>already<sp/>were<sp/>containers,<sp/>resizing.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_num_items<sp/>&lt;<sp/>ArraySize(containers))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Deleting<sp/>not<sp/>needed<sp/>containers.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>_num_items;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delete<sp/>containers[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ArrayResize(containers,<sp/>_num_items);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_DIMENSION_TYPE_VALUES:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_last_size<sp/>=<sp/>ArraySize(values);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ArrayResize(values,<sp/>_num_items);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_num_items<sp/>&gt;<sp/>_last_size)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Clearing<sp/>new<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ArrayFill(values,<sp/>_last_size,<sp/>_num_items<sp/>-<sp/>_last_size,<sp/>(X)0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>type<sp/>=<sp/>_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Initializes<sp/>dimensions<sp/>deeply.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@todo<sp/>Allow<sp/>of<sp/>resizing<sp/>containers<sp/>instead<sp/>of<sp/>freeing<sp/>them<sp/>firstly.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>MatrixDimension&lt;X&gt;*<sp/>SetDimensions(MatrixDimension&lt;X&gt;*<sp/>_ptr_parent_dimension,<sp/>int&amp;<sp/>_dimensions[],<sp/>int<sp/>index,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int&amp;<sp/>_current_position[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_ptr_parent_dimension<sp/>==<sp/>NULL)<sp/>_ptr_parent_dimension<sp/>=<sp/>new<sp/>MatrixDimension();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_dimensions[index]<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Matrix<sp/>with<sp/>no<sp/>dimensions.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_ptr_parent_dimension;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_ptr_parent_dimension.SetPosition(_current_position,<sp/>index);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_dimensions[index<sp/>+<sp/>1]<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_ptr_parent_dimension.Resize(_dimensions[index],<sp/>MATRIX_DIMENSION_TYPE_VALUES);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_ptr_parent_dimension.Resize(_dimensions[index],<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>_dimensions[index];<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_ptr_parent_dimension.containers[i]<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SetDimensions(_ptr_parent_dimension.containers[i],<sp/>_dimensions,<sp/>index<sp/>+<sp/>1,<sp/>_current_position);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++_current_position[index];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_ptr_parent_dimension;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Executes<sp/>operation<sp/>on<sp/>a<sp/>single<sp/>value.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>OpSingle(ENUM_MATRIX_OPERATION<sp/>_op,<sp/>X<sp/>_src<sp/>=<sp/>(X)0,<sp/>X<sp/>_arg1<sp/>=<sp/>(X)0,<sp/>X<sp/>_arg2<sp/>=<sp/>(X)0,<sp/>X<sp/>_arg3<sp/>=<sp/>(X)0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_pos<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(_op)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ABS:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>MathAbs(_src);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ADD:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_src<sp/>+<sp/>_arg1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_SUBTRACT:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_src<sp/>-<sp/>_arg1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_MULTIPLY:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_src<sp/>*<sp/>_arg1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_DIVIDE:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_src<sp/>/<sp/>_arg1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_FILL:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_arg1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_FILL_RANDOM:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_arg1<sp/>!=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>srand((int)_arg3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-(X)1<sp/>+<sp/>(X)MathRand()<sp/>/<sp/>32767<sp/>*<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_FILL_RANDOM_RANGE:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_arg3<sp/>!=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>srand((int)_arg3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(X)MathRand()<sp/>/<sp/>32767<sp/>*<sp/>(_arg2<sp/>-<sp/>_arg1)<sp/>+<sp/>_arg1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ABS_DIFF:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>MathAbs(_src<sp/>-<sp/>_arg1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ABS_DIFF_SQUARE:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>pow(MathAbs(_src<sp/>-<sp/>_arg1),<sp/>(X)2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>pow(log(_src<sp/>+<sp/>1)<sp/>-<sp/>log(_arg1<sp/>+<sp/>1),<sp/>(X)2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_POISSON:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_arg1<sp/>-<sp/>_src<sp/>*<sp/>log(_arg1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_LOG_COSH:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>log((exp((b-a))<sp/>+<sp/>exp(-(b-a)))/2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>log((exp((_arg1<sp/>-<sp/>_src))<sp/>+<sp/>exp(-(_arg1<sp/>-<sp/>_src)))<sp/>/<sp/>(X)2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_RELU:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>Math::ReLU(_src);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;MatrixDimension::OpSingle():<sp/>Invalid<sp/>operation<sp/>&quot;,<sp/>EnumToString(_op),<sp/>&quot;!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(X)0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Executes<sp/>operation<sp/>on<sp/>all<sp/>matrix&apos;s<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Op(ENUM_MATRIX_OPERATION<sp/>_op,<sp/>X<sp/>_arg1,<sp/>X<sp/>_arg2,<sp/>X<sp/>_arg3,<sp/>X&amp;<sp/>_out1,<sp/>X&amp;<sp/>_out2,<sp/>int&amp;<sp/>_out3)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i,<sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>containers[i].Op(_op,<sp/>_arg1,<sp/>_arg2,<sp/>_arg3,<sp/>_out1,<sp/>_out2,<sp/>_out3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(values);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(_op)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ABS:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ADD:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_SUBTRACT:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_MULTIPLY:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_DIVIDE:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_FILL:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_FILL_RANDOM:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_FILL_RANDOM_RANGE:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_POISSON:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_LOG_COSH:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_RELU:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>=<sp/>OpSingle(_op,<sp/>values[i],<sp/>_arg1,<sp/>_arg2,<sp/>_arg3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_FILL_POS_ADD:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>ArraySize(position);<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(position[k]<sp/>==<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>+=<sp/>position[k];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>+=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_FILL_POS_MUL:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>=<sp/>MinOf((X)0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>ArraySize(position);<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(position[k]<sp/>==<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>=<sp/>(values[i]<sp/>==<sp/>MinOf((X)0))<sp/>?<sp/>position[k]<sp/>:<sp/>values[i]<sp/>*<sp/>position[k];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>=<sp/>(values[i]<sp/>==<sp/>MinOf((X)0))<sp/>?<sp/>i<sp/>:<sp/>values[i]<sp/>*<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_POWER:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>=<sp/>pow(values[i],<sp/>_arg1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_SUM:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_out1<sp/>+=<sp/>values[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_MIN:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(values[i]<sp/>&lt;<sp/>_out1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_out1<sp/>=<sp/>values[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_MAX:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(values[i]<sp/>&gt;<sp/>_out1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_out1<sp/>=<sp/>values[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ABS_DIFF:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>=<sp/>MathAbs(values[i]<sp/>-<sp/>_arg1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;MatrixDimension::Op():<sp/>Invalid<sp/>operation<sp/>&quot;,<sp/>EnumToString(_op),<sp/>&quot;!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Executes<sp/>operation<sp/>on<sp/>the<sp/>children<sp/>containers<sp/>and<sp/>values.<sp/>Used<sp/>internally.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Op(ENUM_MATRIX_OPERATION<sp/>_op,<sp/>X<sp/>_arg1<sp/>=<sp/>(X)0,<sp/>X<sp/>_arg2<sp/>=<sp/>(X)0,<sp/>X<sp/>_arg3<sp/>=<sp/>(X)0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_out1,<sp/>_out2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_out3;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Op(_op,<sp/>_arg1,<sp/>_arg2,<sp/>_arg3,<sp/>_out1,<sp/>_out2,<sp/>_out3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Extracts<sp/>dimensions&apos;s<sp/>values<sp/>to<sp/>the<sp/>given<sp/>array.<sp/>Used<sp/>internally.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillArray(X&amp;<sp/>array[],<sp/>int&amp;<sp/>offset)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>containers[i].FillArray(array,<sp/>offset);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(values);<sp/>++i,<sp/>++offset)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>array[offset]<sp/>=<sp/>values[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FromArray(X&amp;<sp/>_array[],<sp/>int&amp;<sp/>offset)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(type)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>containers[i].FromArray(_array,<sp/>offset);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_DIMENSION_TYPE_VALUES:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(values);<sp/>++i,<sp/>++offset)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>=<sp/>_array[offset];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Performs<sp/>operation<sp/>between<sp/>current<sp/>matrix/tensor<sp/>and<sp/>another<sp/>one<sp/>of<sp/>the<sp/>same<sp/>or<sp/>lower<sp/>level.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Op(MatrixDimension&lt;X&gt;*<sp/>_r,<sp/>ENUM_MATRIX_OPERATION<sp/>_op,<sp/>X<sp/>_arg1<sp/>=<sp/>(X)0,<sp/>int<sp/>_only_value_index<sp/>=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>r_is_single<sp/>=<sp/>ArraySize(_r.values)<sp/>==<sp/>1;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_r.type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES<sp/>&amp;&amp;<sp/>ArraySize(_r.values)<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>There<sp/>is<sp/>only<sp/>one<sp/>value<sp/>in<sp/>the<sp/>right<sp/>container,<sp/>we<sp/>will<sp/>use<sp/>that<sp/>value<sp/>for<sp/>all<sp/>operations.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_only_value_index<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(type)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(_r.type)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Both<sp/>dimensions<sp/>have<sp/>containers.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>containers[i].Op(_r.containers[ArraySize(_r.containers)<sp/>==<sp/>1<sp/>?<sp/>0<sp/>:<sp/>i],<sp/>_op,<sp/>_arg1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_DIMENSION_TYPE_VALUES:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Left<sp/>dimension<sp/>have<sp/>containers,<sp/>but<sp/>right<sp/>dimension<sp/>have<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(containers);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>If<sp/>there<sp/>is<sp/>only<sp/>a<sp/>single<sp/>value<sp/>in<sp/>the<sp/>right<sp/>dimension,<sp/>use<sp/>it<sp/>for<sp/>all<sp/>operations<sp/>inside<sp/>current</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>container.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>containers[i].Op(_r,<sp/>_op,<sp/>_arg1,<sp/>_only_value_index<sp/>!=<sp/>-1<sp/>?<sp/>_only_value_index<sp/>:<sp/>i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_DIMENSION_TYPE_VALUES:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(_r.type)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Right<sp/>dimension<sp/>have<sp/>containers.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(ArraySize(_r.containers)<sp/>!=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alert(&quot;Right<sp/>container<sp/>must<sp/>have<sp/>exactly<sp/>one<sp/>element!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Op(_r.containers[0],<sp/>_op,<sp/>_arg1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_DIMENSION_TYPE_VALUES:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Left<sp/>and<sp/>right<sp/>dimensions<sp/>have<sp/>values<sp/>or<sp/>we<sp/>use<sp/>single<sp/>right<sp/>value.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(values);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>values[i]<sp/>=<sp/>OpSingle(_op,<sp/>values[i],<sp/>_r.values[_only_value_index<sp/>!=<sp/>-1<sp/>?<sp/>_only_value_index<sp/>:<sp/>i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Matrix<sp/>class.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>X&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Matrix<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>First/root<sp/>dimension.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MatrixDimension&lt;X&gt;*<sp/>ptr_first_dimension;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Array<sp/>with<sp/>declaration<sp/>of<sp/>items<sp/>per<sp/>matrix&apos;s<sp/>dimension.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>dimensions[MATRIX_DIMENSIONS];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Current<sp/>size<sp/>of<sp/>the<sp/>matrix<sp/>(all<sp/>dimensions<sp/>multiplied).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>size;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Number<sp/>of<sp/>matrix<sp/>dimensions.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>num_dimensions;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix(string<sp/>_data)<sp/>{<sp/>FromString(_data);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix(const<sp/>int<sp/>num_1d<sp/>=<sp/>0,<sp/>const<sp/>int<sp/>num_2d<sp/>=<sp/>0,<sp/>const<sp/>int<sp/>num_3d<sp/>=<sp/>0,<sp/>const<sp/>int<sp/>num_4d<sp/>=<sp/>0,<sp/>const<sp/>int<sp/>num_5d<sp/>=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ptr_first_dimension<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SetShape(num_1d,<sp/>num_2d,<sp/>num_3d,<sp/>num_4d,<sp/>num_5d);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix(MatrixDimension&lt;X&gt;*<sp/>_dimension)<sp/>:<sp/>ptr_first_dimension(NULL)<sp/>{<sp/>Initialize(_dimension);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Copy<sp/>constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix(const<sp/>Matrix&lt;X&gt;&amp;<sp/>_right)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_right.ptr_first_dimension<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Initialize(_right.ptr_first_dimension.Clone());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Private<sp/>copy<sp/>constructor.<sp/>We<sp/>don&apos;t<sp/>want<sp/>to<sp/>assign<sp/>Matrix<sp/>via<sp/>pointer<sp/>due<sp/>to<sp/>memory<sp/>leakage.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix(const<sp/>Matrix&lt;X&gt;*<sp/>_right)<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Matrix<sp/>initializer.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Initialize(MatrixDimension&lt;X&gt;*<sp/>_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension<sp/>!=<sp/>NULL)<sp/>delete<sp/>ptr_first_dimension;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ptr_first_dimension<sp/>=<sp/>_dimension;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Calculating<sp/>dimensions.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>MATRIX_DIMENSIONS;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dimensions[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>MATRIX_DIMENSIONS;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_dimension<sp/>==<sp/>NULL)<sp/>break;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_dimension.type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dimensions[i]<sp/>=<sp/>ArraySize(_dimension.containers);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_dimension<sp/>=<sp/>_dimension.containers[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(_dimension.type<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dimensions[i++]<sp/>=<sp/>ArraySize(_dimension.values);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Internal<sp/>error:<sp/>unknown<sp/>dimension<sp/>type!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>num_dimensions<sp/>=<sp/>i;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RecalculateSize();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>RecalculateSize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(dimensions);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dimensions[i]<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size<sp/>*=<sp/>dimensions[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Assignment<sp/>operator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator=(const<sp/>Matrix&lt;X&gt;&amp;<sp/>_right)<sp/>{<sp/>Initialize(_right.ptr_first_dimension.Clone());<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Assignment<sp/>operator.<sp/>Initializes<sp/>matrix<sp/>using<sp/>given<sp/>dimension.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix(MatrixDimensionAccessor&lt;X&gt;&amp;<sp/>accessor)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Initialize(accessor.ptr_dimension.containers[accessor.index].Clone());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>SetShape(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>this[0]<sp/>=<sp/>accessor.Val();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Assignment<sp/>operator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator=(string<sp/>_data)<sp/>{<sp/>FromString(_data);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Destructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>~Matrix()<sp/>{<sp/>delete<sp/>ptr_first_dimension;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Index<sp/>operator.<sp/>Returns<sp/>container<sp/>or<sp/>value<sp/>accessor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MatrixDimensionAccessor&lt;X&gt;<sp/>operator[](int<sp/>index)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MatrixDimensionAccessor&lt;X&gt;<sp/>accessor(&amp;this,<sp/>ptr_first_dimension,<sp/>index);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>accessor;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Sets<sp/>or<sp/>changes<sp/>matrix&apos;s<sp/>dimensions.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>SetShape(const<sp/>int<sp/>num_1d<sp/>=<sp/>0,<sp/>const<sp/>int<sp/>num_2d<sp/>=<sp/>0,<sp/>const<sp/>int<sp/>num_3d<sp/>=<sp/>0,<sp/>const<sp/>int<sp/>num_4d<sp/>=<sp/>0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int<sp/>num_5d<sp/>=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dimensions[0]<sp/>=<sp/>num_1d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dimensions[1]<sp/>=<sp/>num_2d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dimensions[2]<sp/>=<sp/>num_3d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dimensions[3]<sp/>=<sp/>num_4d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dimensions[4]<sp/>=<sp/>num_5d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dimensions[5]<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_current_position[]<sp/>=<sp/>{0,<sp/>0,<sp/>0,<sp/>0};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ptr_first_dimension<sp/>=<sp/>MatrixDimension&lt;X&gt;::SetDimensions(ptr_first_dimension,<sp/>dimensions,<sp/>0,<sp/>_current_position);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Calculating<sp/>size.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>num_dimensions<sp/>=<sp/>(num_1d<sp/>!=<sp/>0<sp/>?<sp/>1<sp/>:<sp/>0)<sp/>+<sp/>(num_2d<sp/>!=<sp/>0<sp/>?<sp/>1<sp/>:<sp/>0)<sp/>+<sp/>(num_3d<sp/>!=<sp/>0<sp/>?<sp/>1<sp/>:<sp/>0)<sp/>+<sp/>(num_4d<sp/>!=<sp/>0<sp/>?<sp/>1<sp/>:<sp/>0)<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(num_5d<sp/>!=<sp/>0<sp/>?<sp/>1<sp/>:<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Calculating<sp/>size.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>MATRIX_DIMENSIONS;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dimensions[i]<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size<sp/>*=<sp/>dimensions[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>length<sp/>of<sp/>the<sp/>given<sp/>dimension.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>GetRange(int<sp/>_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_dimension<sp/>&gt;=<sp/>MATRIX_DIMENSIONS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Matrix::GetRange():<sp/>Dimension<sp/>should<sp/>be<sp/>between<sp/>0<sp/>and<sp/>&quot;,<sp/>MATRIX_DIMENSIONS<sp/>-<sp/>1,<sp/>&quot;.<sp/>Got<sp/>&quot;,<sp/>_dimension,<sp/>&quot;!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>dimensions[_dimension];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>total<sp/>number<sp/>of<sp/>values<sp/>the<sp/>matrix<sp/>contain<sp/>of.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>GetSize()<sp/>{<sp/>return<sp/>size;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>number<sp/>of<sp/>matrix<sp/>dimensions.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>GetDimensions()<sp/>{<sp/>return<sp/>num_dimensions;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>DuplicateDimension(int<sp/>_level,<sp/>int<sp/>_num,<sp/>int<sp/>_current_level<sp/>=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_num<sp/>&lt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_level<sp/>&gt;=<sp/>GetDimensions())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>initial_container_size<sp/>=<sp/>ptr_first_dimension.DuplicateDimension(_level,<sp/>_num);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dimensions[_level]<sp/>+=<sp/>_num<sp/>*<sp/>initial_container_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RecalculateSize();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>value<sp/>at<sp/>the<sp/>given<sp/>position.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>GetValue(int<sp/>_pos_1d,<sp/>int<sp/>_pos_2d<sp/>=<sp/>-1,<sp/>int<sp/>_pos_3d<sp/>=<sp/>-1,<sp/>int<sp/>_pos_4d<sp/>=<sp/>-1,<sp/>int<sp/>_pos_5d<sp/>=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MatrixDimensionAccessor&lt;X&gt;<sp/>accessor<sp/>=<sp/>this[_pos_1d];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>accessor[_pos_2d];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>accessor[_pos_3d];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>accessor[_pos_4d];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alert(&quot;Matrix::GetValue():<sp/>Internal<sp/>error.<sp/>Last<sp/>dimensions<sp/>shouldn&apos;t<sp/>be<sp/>a<sp/>container!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>accessor.Val();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>value<sp/>at<sp/>the<sp/>given<sp/>position<sp/>(or<sp/>parent<sp/>one<sp/>for<sp/>missing<sp/>dimensions,<sp/>or<sp/>zero<sp/>for<sp/>missing<sp/>indices).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>GetValueLossely(int<sp/>_source_dimensions,<sp/>int<sp/>_pos_1d,<sp/>int<sp/>_pos_2d<sp/>=<sp/>-1,<sp/>int<sp/>_pos_3d<sp/>=<sp/>-1,<sp/>int<sp/>_pos_4d<sp/>=<sp/>-1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>_pos_5d<sp/>=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_shift_dimensions<sp/>=<sp/>_source_dimensions<sp/>-<sp/>GetDimensions();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(_shift_dimensions--<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_pos_1d<sp/>=<sp/>_pos_2d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_pos_2d<sp/>=<sp/>_pos_3d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_pos_3d<sp/>=<sp/>_pos_4d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_pos_4d<sp/>=<sp/>_pos_5d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_pos_5d<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(GetDimensions()<sp/>&lt;<sp/>1)<sp/>return<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MatrixDimensionAccessor&lt;X&gt;<sp/>accessor;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_pos_1d<sp/>&gt;=<sp/>dimensions[0])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dimensions[0]<sp/>==<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_pos_1d<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>this[_pos_1d];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Returning<sp/>prematurely<sp/>if<sp/>we<sp/>experienced<sp/>value<sp/>instead<sp/>of<sp/>a<sp/>container.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>return<sp/>accessor.Val();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_pos_2d<sp/>&gt;=<sp/>dimensions[1])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dimensions[1]<sp/>==<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_pos_2d<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>accessor[_pos_2d];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Returning<sp/>prematurely<sp/>if<sp/>we<sp/>experienced<sp/>value<sp/>instead<sp/>of<sp/>a<sp/>container.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>return<sp/>accessor.Val();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_pos_3d<sp/>&gt;=<sp/>dimensions[2])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dimensions[2]<sp/>==<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_pos_3d<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>accessor[_pos_3d];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Returning<sp/>prematurely<sp/>if<sp/>we<sp/>experienced<sp/>value<sp/>instead<sp/>of<sp/>a<sp/>container.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>return<sp/>accessor.Val();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_pos_4d<sp/>&gt;=<sp/>dimensions[3])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dimensions[3]<sp/>==<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_pos_4d<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>accessor[_pos_4d];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Returning<sp/>prematurely<sp/>if<sp/>we<sp/>experienced<sp/>value<sp/>instead<sp/>of<sp/>a<sp/>container.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>return<sp/>accessor.Val();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_pos_5d<sp/>&gt;=<sp/>dimensions[4])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dimensions[4]<sp/>==<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_pos_5d<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>accessor[_pos_5d];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Returning<sp/>prematurely<sp/>if<sp/>we<sp/>experienced<sp/>value<sp/>instead<sp/>of<sp/>a<sp/>container.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>return<sp/>accessor.Val();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Alert(&quot;Matrix::GetValueLossely():<sp/>Internal<sp/>error.<sp/>Last<sp/>dimensions<sp/>shouldn&apos;t<sp/>be<sp/>a<sp/>container!&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>values<sp/>at<sp/>the<sp/>given<sp/>position.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>SetValue(X<sp/>_value,<sp/>int<sp/>_pos_1d,<sp/>int<sp/>_pos_2d<sp/>=<sp/>-1,<sp/>int<sp/>_pos_3d<sp/>=<sp/>-1,<sp/>int<sp/>_pos_4d<sp/>=<sp/>-1,<sp/>int<sp/>_pos_5d<sp/>=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MatrixDimensionAccessor&lt;X&gt;<sp/>accessor<sp/>=<sp/>this[_pos_1d];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>accessor[_pos_2d];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>accessor[_pos_3d];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>accessor[_pos_4d];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(accessor.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alert(&quot;Matrix::GetValue():<sp/>Internal<sp/>error.<sp/>Last<sp/>dimensions<sp/>shouldn&apos;t<sp/>be<sp/>a<sp/>container!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>accessor<sp/>=<sp/>_value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Increments<sp/>all<sp/>existing<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>given<sp/>one.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator+=(X<sp/>value)<sp/>{<sp/>Add(value);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Makes<sp/>all<sp/>values<sp/>absolute<sp/>(negatives<sp/>becomes<sp/>positive).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Abs()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_ABS);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Increments<sp/>all<sp/>existing<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>given<sp/>one.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Add(X<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_ADD,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Decrements<sp/>all<sp/>existing<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>given<sp/>one.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator-=(X<sp/>value)<sp/>{<sp/>Sub(value);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Decrements<sp/>all<sp/>existing<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>given<sp/>one.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Sub(X<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_SUBTRACT,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Multiplies<sp/>all<sp/>existing<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>given<sp/>one.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator*=(X<sp/>value)<sp/>{<sp/>Mul(value);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Multiplies<sp/>all<sp/>existing<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>given<sp/>one.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Mul(X<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_MULTIPLY,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Divides<sp/>all<sp/>existing<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>given<sp/>one.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator/=(X<sp/>value)<sp/>{<sp/>Div(value);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Divides<sp/>all<sp/>existing<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>given<sp/>one.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Div(X<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_DIVIDE,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Replaces<sp/>all<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>given<sp/>one.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Fill(X<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_FILL,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Replaces<sp/>existing<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>random<sp/>one<sp/>(-1.0<sp/>-<sp/>1.0).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillRandom(int<sp/>_seed<sp/>=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_FILL_RANDOM,<sp/>_seed);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Replaces<sp/>existing<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>random<sp/>value<sp/>from<sp/>a<sp/>given<sp/>range.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillRandom(X<sp/>_start,<sp/>X<sp/>_end,<sp/>int<sp/>_seed<sp/>=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_FILL_RANDOM_RANGE,<sp/>_start,<sp/>_end,<sp/>_seed);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Fills<sp/>matrix<sp/>with<sp/>values<sp/>which<sp/>are<sp/>sum<sp/>of<sp/>all<sp/>the<sp/>matrix<sp/>coordinates.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillPosAdd()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_FILL_POS_ADD);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Fills<sp/>matrix<sp/>with<sp/>values<sp/>which<sp/>are<sp/>multiply<sp/>of<sp/>all<sp/>the<sp/>matrix<sp/>coordinates.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillPosMul()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_FILL_POS_MUL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Replaces<sp/>existing<sp/>matrix&apos;s<sp/>values<sp/>by<sp/>random<sp/>value<sp/>from<sp/>a<sp/>given<sp/>range.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>Sum()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_out1<sp/>=<sp/>0,<sp/>_out2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_out3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_SUM,<sp/>0,<sp/>0,<sp/>0,<sp/>_out1,<sp/>_out2,<sp/>_out3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_out1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>the<sp/>lowest<sp/>value<sp/>in<sp/>the<sp/>whole<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>Min()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_out1<sp/>=<sp/>MaxOf((X)0),<sp/>_out2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_out3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_MIN,<sp/>0,<sp/>0,<sp/>0,<sp/>_out1,<sp/>_out2,<sp/>_out3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_out1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>the<sp/>lowest<sp/>value<sp/>in<sp/>the<sp/>whole<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>Max()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_out1<sp/>=<sp/>MinOf((X)0),<sp/>_out2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_out3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_MAX,<sp/>0,<sp/>0,<sp/>0,<sp/>_out1,<sp/>_out2,<sp/>_out3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_out1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>the<sp/>average<sp/>value<sp/>in<sp/>the<sp/>whole<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>Avg()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_out1<sp/>=<sp/>0,<sp/>_out2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_out3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_SUM,<sp/>0,<sp/>0,<sp/>0,<sp/>_out1,<sp/>_out2,<sp/>_out3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_out1<sp/>/<sp/>GetSize();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>MinOf((X)0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Power(X<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_POWER,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>median<sp/>of<sp/>the<sp/>matrix<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>Med()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>X<sp/>array[];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>GetRawArray(array);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ArraySort(array);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>median;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>len<sp/>=<sp/>ArraySize(array);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(len<sp/>%<sp/>2<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>median<sp/>=<sp/>(array[len<sp/>/<sp/>2]<sp/>+<sp/>array[(len<sp/>/<sp/>2)<sp/>-<sp/>1])<sp/>/<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>median<sp/>=<sp/>array[len<sp/>/<sp/>2];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>median;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>MinOf((X)0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Performs<sp/>matrix<sp/>multiplication.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>MatMul(Matrix&lt;X&gt;&amp;<sp/>target)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(GetSize()<sp/>!=<sp/>target.GetRange(1))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Alert(&quot;Inconsistent<sp/>size<sp/>of<sp/>matrices!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>num_outputs<sp/>=<sp/>target.GetRange(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>num_inputs<sp/>=<sp/>target.GetRange(1);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>outputs<sp/>=<sp/>new<sp/>Matrix&lt;X&gt;(num_outputs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>output_idx<sp/>=<sp/>0;<sp/>output_idx<sp/>&lt;<sp/>num_outputs;<sp/>++output_idx)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>outputs[output_idx]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>input_idx<sp/>=<sp/>0;<sp/>input_idx<sp/>&lt;<sp/>num_inputs;<sp/>++input_idx)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outputs[output_idx]<sp/>+=<sp/>this[input_idx].Val()<sp/>*<sp/>target[output_idx][input_idx].Val();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>outputs[output_idx]<sp/>=<sp/>outputs[output_idx].Val();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>outputs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Performs<sp/>matrix<sp/>multiplication.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>operator^(Matrix&lt;X&gt;&amp;<sp/>target)<sp/>{<sp/>return<sp/>MatMul(target);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Matrix-matrix<sp/>addition<sp/>operator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>operator+(const<sp/>Matrix&lt;X&gt;&amp;<sp/>r)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>result<sp/>=<sp/>Clone();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(result.ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>result.ptr_first_dimension.Op(r.ptr_first_dimension,<sp/>MATRIX_OPERATION_ADD);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Matrix-matrix<sp/>inplace<sp/>addition<sp/>operator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator+=(const<sp/>Matrix&lt;X&gt;&amp;<sp/>r)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension<sp/>&amp;&amp;<sp/>r.ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(r.ptr_first_dimension,<sp/>MATRIX_OPERATION_ADD);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Matrix-matrix<sp/>subtraction<sp/>operator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>operator-(const<sp/>Matrix&lt;X&gt;&amp;<sp/>r)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>result<sp/>=<sp/>Clone();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(result.ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>result.ptr_first_dimension.Op(r.ptr_first_dimension,<sp/>MATRIX_OPERATION_SUBTRACT);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Matrix-matrix<sp/>inplace<sp/>subtraction<sp/>operator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator-=(const<sp/>Matrix&lt;X&gt;&amp;<sp/>r)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension<sp/>&amp;&amp;<sp/>r.ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(r.ptr_first_dimension,<sp/>MATRIX_OPERATION_SUBTRACT);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Matrix-matrix<sp/>multiplication<sp/>operator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>operator*(const<sp/>Matrix&lt;X&gt;&amp;<sp/>r)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>result<sp/>=<sp/>Clone();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(result.ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>result.ptr_first_dimension.Op(r.ptr_first_dimension,<sp/>MATRIX_OPERATION_MULTIPLY);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Matrix-matrix<sp/>inplace<sp/>multiplication<sp/>operator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator*=(const<sp/>Matrix&lt;X&gt;&amp;<sp/>r)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension<sp/>&amp;&amp;<sp/>r.ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(r.ptr_first_dimension,<sp/>MATRIX_OPERATION_MULTIPLY);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Matrix-matrix<sp/>division<sp/>operator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>operator/(const<sp/>Matrix&lt;X&gt;&amp;<sp/>r)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>result<sp/>=<sp/>Clone();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(result.ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>result.ptr_first_dimension.Op(r.ptr_first_dimension,<sp/>MATRIX_OPERATION_DIVIDE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Matrix-matrix<sp/>inplace<sp/>division<sp/>operator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator/=(const<sp/>Matrix&lt;X&gt;&amp;<sp/>r)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension<sp/>&amp;&amp;<sp/>r.ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(r.ptr_first_dimension,<sp/>MATRIX_OPERATION_DIVIDE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Fills<sp/>array<sp/>with<sp/>all<sp/>values<sp/>from<sp/>the<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>GetRawArray(X&amp;<sp/>array[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ArrayResize(array,<sp/>GetSize());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>offset<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ptr_first_dimension.FillArray(array,<sp/>offset);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Flattens<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>Flatten()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>values[];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GetRawArray(values);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>result<sp/>=<sp/>new<sp/>Matrix&lt;X&gt;(ArraySize(values));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(values);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>result[i]<sp/>=<sp/>values[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Initializer<sp/>that<sp/>generates<sp/>tensors<sp/>with<sp/>a<sp/>uniform<sp/>distribution.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillRandomUniform(X<sp/>_min,<sp/>X<sp/>_max,<sp/>int<sp/>_seed<sp/>=<sp/>-1)<sp/>{<sp/>FillRandom(_min,<sp/>_max,<sp/>_seed);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifdef<sp/>USE_MQL_MATH_STAT</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Initializer<sp/>that<sp/>generates<sp/>tensors<sp/>with<sp/>a<sp/>normal<sp/>distribution.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillRandomNormal(X<sp/>_mean,<sp/>X<sp/>_stddev,<sp/>int<sp/>_seed<sp/>=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>__MQL5__</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_seed<sp/>!=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Matrix::FillRandomNormal():<sp/>_seed<sp/>parameter<sp/>is<sp/>not<sp/>yet<sp/>implemented!<sp/>Please<sp/>use<sp/>-1<sp/>as<sp/>_seed.&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>_values[];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MathRandomNormal(_mean,<sp/>_stddev,<sp/>GetSize(),<sp/>_values);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FillFromArray(_values);</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Print(&quot;Matrix::FillRandomNormal()<sp/>is<sp/>implemented<sp/>only<sp/>in<sp/>MQL5!&quot;);</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillFromArray(X&amp;<sp/>_array[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ArraySize(_array)<sp/>!=<sp/>GetSize())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Matrix::FillFromArray():<sp/>input<sp/>array<sp/>(&quot;,<sp/>ArraySize(_array),<sp/>&quot;<sp/>elements)<sp/>must<sp/>be<sp/>the<sp/>same<sp/>size<sp/>as<sp/>matrix<sp/>(&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>GetSize(),<sp/>&quot;<sp/>elements)!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>offset<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ptr_first_dimension.FromArray(_array,<sp/>offset);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Initializer<sp/>that<sp/>generates<sp/>a<sp/>truncated<sp/>normal<sp/>distribution.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillTruncatedNormal(X<sp/>_mean,<sp/>X<sp/>_stddev,<sp/>int<sp/>_seeds<sp/>=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Print(&quot;Matrix::FillTruncatedNormal()<sp/>is<sp/>not<sp/>yet<sp/>implemented!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>The<sp/>Glorot<sp/>normal<sp/>initializer,<sp/>also<sp/>called<sp/>Xavier<sp/>normal<sp/>initializer.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillGlorotNormal(int<sp/>_seed<sp/>=<sp/>-1)<sp/>{<sp/>Print(&quot;Matrix::FillGlorotNormal()<sp/>is<sp/>not<sp/>yet<sp/>implemented!&quot;);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>The<sp/>Glorot<sp/>uniform<sp/>initializer,<sp/>also<sp/>called<sp/>Xavier<sp/>uniform<sp/>initializer.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillGlorotUniform(int<sp/>_seed<sp/>=<sp/>-1)<sp/>{<sp/>Print(&quot;Matrix::FillGlorotUniform()<sp/>is<sp/>not<sp/>yet<sp/>implemented!&quot;);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Initializer<sp/>that<sp/>generates<sp/>the<sp/>identity<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillIdentity(X<sp/>_gain<sp/>=<sp/>(X)1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(GetDimensions()<sp/>!=<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Matrix::FillIdentity()<sp/>has<sp/>no<sp/>sense<sp/>in<sp/>the<sp/>non-2d<sp/>matrix!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(GetRange(0)<sp/>!=<sp/>GetRange(1))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Matrix::FillIdentity():<sp/>Both<sp/>dimensions<sp/>should<sp/>have<sp/>exact<sp/>size!<sp/>Passed<sp/>&quot;,<sp/>Repr(),<sp/>&quot;.&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Fill(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>GetRange(0);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>this[i][i]<sp/>=<sp/>_gain;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Initializer<sp/>that<sp/>generates<sp/>an<sp/>orthogonal<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FillOrthogonal(X<sp/>_gain,<sp/>int<sp/>_seed<sp/>=<sp/>-1)<sp/>{<sp/>Print(&quot;Matrix::FillOrthogonal()<sp/>is<sp/>not<sp/>yet<sp/>implemented!&quot;);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>absolute<sp/>difference<sp/>between<sp/>this<sp/>tensor<sp/>and<sp/>given<sp/>one<sp/>using<sp/>optional<sp/>weights<sp/>tensor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>Mean(ENUM_MATRIX_OPERATION<sp/>_abs_diff_op,<sp/>ENUM_MATRIX_OPERATION<sp/>_reduction,<sp/>Matrix&lt;X&gt;*<sp/>_prediction,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>_weights<sp/>=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(_abs_diff_op)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ABS_DIFF:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ABS_DIFF_SQUARE:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Mean():<sp/>Unsupported<sp/>absolute<sp/>difference<sp/>operator:<sp/>&quot;,<sp/>EnumToString(_abs_diff_op),<sp/>&quot;!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!ShapeCompatible(&amp;this,<sp/>_prediction))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;MeanAbsolute():<sp/>Shape<sp/>&quot;,<sp/>Repr(),<sp/>&quot;<sp/>is<sp/>not<sp/>compatible<sp/>with<sp/>prediction<sp/>shape<sp/>&quot;,<sp/>_prediction.Repr(),<sp/>&quot;!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_weights<sp/>!=<sp/>NULL<sp/>&amp;&amp;<sp/>_weights.GetDimensions()<sp/>&gt;<sp/>this.GetDimensions())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;MeanAbsolute():<sp/>Shape<sp/>&quot;,<sp/>Repr(),<sp/>&quot;:<sp/>Weights<sp/>must<sp/>be<sp/>a<sp/>tensor<sp/>level<sp/>&lt;=<sp/>&quot;,<sp/>this.GetDimensions(),<sp/>&quot;!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*_matrix,<sp/>*_pooled;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>We&apos;ll<sp/>be<sp/>working<sp/>on<sp/>copy<sp/>of<sp/>the<sp/>current<sp/>tensor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_matrix<sp/>=<sp/>Clone();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Calculating<sp/>absolute<sp/>difference<sp/>between<sp/>copied<sp/>tensor<sp/>and<sp/>given<sp/>prediction.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_matrix.ptr_first_dimension.Op(_prediction.ptr_first_dimension,<sp/>_abs_diff_op);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(_abs_diff_op)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ABS_DIFF_SQUARE:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Reducing<sp/>values<sp/>of<sp/>the<sp/>last<sp/>dimension<sp/>of<sp/>the<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_pooled<sp/>=<sp/>_matrix.GetPooled(_reduction,<sp/>MATRIX_PADDING_SAME,<sp/>dimensions[1]<sp/>==<sp/>0<sp/>?<sp/>dimensions[0]<sp/>:<sp/>1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dimensions[2]<sp/>==<sp/>0<sp/>?<sp/>dimensions[1]<sp/>:<sp/>1,<sp/>dimensions[3]<sp/>==<sp/>0<sp/>?<sp/>dimensions[2]<sp/>:<sp/>1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dimensions[4]<sp/>==<sp/>0<sp/>?<sp/>dimensions[3]<sp/>:<sp/>1,<sp/>dimensions[5]<sp/>==<sp/>0<sp/>?<sp/>dimensions[4]<sp/>:<sp/>1);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Physically<sp/>reducing<sp/>last<sp/>dimension<sp/>of<sp/>the<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_pooled.ReduceSimple();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delete<sp/>_matrix;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_matrix<sp/>=<sp/>_pooled;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_weights<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Multiplying<sp/>copied<sp/>tensor<sp/>by<sp/>given<sp/>weights.<sp/>Note<sp/>that<sp/>weights<sp/>tensor<sp/>could<sp/>be<sp/>of<sp/>lower<sp/>level<sp/>than<sp/>original</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>tensor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_matrix.ptr_first_dimension.Op(_weights.ptr_first_dimension,<sp/>MATRIX_OPERATION_MULTIPLY);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_matrix;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Reduces<sp/>single<sp/>or<sp/>all<sp/>dimensions<sp/>containing<sp/>only<sp/>a<sp/>single<sp/>value.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>ReduceSimple(bool<sp/>_only_last_dimension<sp/>=<sp/>true,<sp/>ENUM_MATRIX_OPERATION<sp/>_reduce_op<sp/>=<sp/>MATRIX_OPERATION_SUM)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.ReduceSimple(_only_last_dimension<sp/>?<sp/>GetDimensions()<sp/>-<sp/>1<sp/>:<sp/>0,<sp/>_reduce_op);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Reduce(int<sp/>_level<sp/>=<sp/>0,<sp/>ENUM_MATRIX_OPERATION<sp/>_reduce_op<sp/>=<sp/>MATRIX_OPERATION_SUM)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ptr_first_dimension.Reduce(_level,<sp/>_reduce_op);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>_level<sp/>+<sp/>1;<sp/>i<sp/>&lt;<sp/>MATRIX_DIMENSIONS;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dimensions[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RecalculateSize();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Computes<sp/>the<sp/>Poisson<sp/>loss</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>Poisson(Matrix&lt;X&gt;*<sp/>_prediction)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>_clone<sp/>=<sp/>Clone();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_clone.ptr_first_dimension.Op(_prediction.ptr_first_dimension,<sp/>MATRIX_OPERATION_POISSON);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_clone;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Reduces<sp/>matrix<sp/>using<sp/>vector<sp/>math.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Use<sp/>_dimension<sp/>=<sp/>-1<sp/>for<sp/>last<sp/>dimension.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@todo<sp/>Support<sp/>multiple<sp/>dimensions<sp/>for<sp/>reduction.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>VectorReduce(Matrix&lt;X&gt;*<sp/>_product,<sp/>ENUM_MATRIX_VECTOR_REDUCE<sp/>_reduce,<sp/>int<sp/>_dimension<sp/>=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_dimension<sp/>==<sp/>-1)<sp/>_dimension<sp/>=<sp/>GetDimensions()<sp/>-<sp/>1;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!ShapeCompatibleLossely(&amp;this,<sp/>_product))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Alert(&quot;VectorReduce():<sp/>Incompatible<sp/>shapes:<sp/>&quot;,<sp/>Repr(),<sp/>&quot;<sp/>and<sp/>&quot;,<sp/>_product.Repr(),<sp/>&quot;!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>return<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i,<sp/>k,<sp/>_index[]<sp/>=<sp/>{0,<sp/>0,<sp/>0,<sp/>0,<sp/>0,<sp/>0,<sp/>0};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Preparing<sp/>dimension<sp/>indices.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>MATRIX_DIMENSIONS;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dimensions[i]<sp/>==<sp/>0)<sp/>break;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_index[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_out_dims[MATRIX_DIMENSIONS]<sp/>=<sp/>{0,<sp/>0,<sp/>0,<sp/>0,<sp/>0};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_out_index[MATRIX_DIMENSIONS]<sp/>=<sp/>{0,<sp/>0,<sp/>0,<sp/>0,<sp/>0};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Calculating<sp/>output<sp/>matrix<sp/>dimensions.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0,<sp/>k<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>GetDimensions();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>!=<sp/>_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_out_dims[k++]<sp/>=<sp/>dimensions[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>_ptr_result<sp/>=<sp/>new<sp/>Matrix&lt;X&gt;(_out_dims[0],<sp/>_out_dims[1],<sp/>_out_dims[2],<sp/>_out_dims[3],<sp/>_out_dims[4]);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_curr_dimension<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>_stop<sp/>=<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(!_stop)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>X<sp/>_dot<sp/>=<sp/>0,<sp/>_mag1<sp/>=<sp/>0,<sp/>_mag2<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0,<sp/>k<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>GetDimensions();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>!=<sp/>_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_out_index[k++]<sp/>=<sp/>_index[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>X<sp/>_aux1<sp/>=<sp/>0,<sp/>_aux2<sp/>=<sp/>0,<sp/>_aux3<sp/>=<sp/>0,<sp/>_aux4<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>_aux5<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Taking<sp/>one<sp/>group<sp/>at<sp/>a<sp/>time.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>b<sp/>=<sp/>0;<sp/>b<sp/>&lt;<sp/>dimensions[_dimension];<sp/>++b)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X<sp/>_value_a<sp/>=<sp/>GetValue(_index[0],<sp/>_index[1],<sp/>_index[2],<sp/>_index[3],<sp/>_index[4]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X<sp/>_value_b<sp/>=<sp/>_product.GetValueLossely(GetDimensions(),<sp/>_index[0],<sp/>_index[1],<sp/>_index[2],<sp/>_index[3],<sp/>_index[4]);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(_reduce)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_VECTOR_REDUCE_COSINE_SIMILARITY:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Dot.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_aux1<sp/>+=<sp/>_value_a<sp/>*<sp/>_value_b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Mag1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_aux2<sp/>+=<sp/>_value_a<sp/>*<sp/>_value_a;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Mag2.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_aux3<sp/>+=<sp/>_value_b<sp/>*<sp/>_value_b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_VECTOR_REDUCE_HINGE_LOSS:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Sum.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_aux1<sp/>+=<sp/>MathMax(0,<sp/>1<sp/>-<sp/>_value_a<sp/>*<sp/>_value_b);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Counter.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_aux5<sp/>+=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++_index[_dimension];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_index[_dimension]<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>X<sp/>_res<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(_reduce)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_VECTOR_REDUCE_COSINE_SIMILARITY:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_res<sp/>=<sp/>_aux1<sp/>/<sp/>(sqrt(_aux2)<sp/>*<sp/>sqrt(_aux3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_VECTOR_REDUCE_HINGE_LOSS:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Res<sp/>=<sp/>Sum<sp/>/<sp/>Count.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_res<sp/>=<sp/>_aux1<sp/>/<sp/>_aux5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_ptr_result.SetValue(_res,<sp/>_out_index[0],<sp/>_out_index[1],<sp/>_out_index[2],<sp/>_out_index[3],<sp/>_out_index[4]);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_dimension<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++_index[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++_index[0];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>GetDimensions();<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_index[k]<sp/>&gt;=<sp/>dimensions[k])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(k<sp/>&gt;=<sp/>GetDimensions()<sp/>-<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>No<sp/>more<sp/>dimensions.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_stop<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_index[k]<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(k<sp/>+<sp/>1<sp/>==<sp/>_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_dimension<sp/>==<sp/>GetDimensions()<sp/>-<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Incrementing<sp/>last<sp/>dimension<sp/>have<sp/>no<sp/>sense,<sp/>stopping.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_stop<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++_index[k<sp/>+<sp/>2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++_index[k<sp/>+<sp/>1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_ptr_result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>CosineSimilarity(Matrix&lt;X&gt;*<sp/>_product,<sp/>int<sp/>_dimension<sp/>=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>VectorReduce(_product,<sp/>MATRIX_VECTOR_REDUCE_COSINE_SIMILARITY,<sp/>_dimension);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>HingeLoss(Matrix&lt;X&gt;*<sp/>_product)<sp/>{<sp/>return<sp/>VectorReduce(_product,<sp/>MATRIX_VECTOR_REDUCE_HINGE_LOSS,<sp/>-1);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>absolute<sp/>difference<sp/>between<sp/>this<sp/>tensor<sp/>and<sp/>given<sp/>one<sp/>using<sp/>optional<sp/>weights<sp/>tensor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>MeanAbsolute(Matrix&lt;X&gt;*<sp/>_prediction,<sp/>ENUM_MATRIX_OPERATION<sp/>_reduction,<sp/>Matrix&lt;X&gt;*<sp/>_weights<sp/>=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Mean(MATRIX_OPERATION_ABS_DIFF,<sp/>_reduction,<sp/>_prediction,<sp/>_weights);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>squared<sp/>absolute<sp/>difference<sp/>between<sp/>this<sp/>tensor<sp/>and<sp/>given<sp/>one<sp/>using<sp/>optional<sp/>weights<sp/>tensor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>MeanSquared(Matrix&lt;X&gt;*<sp/>_prediction,<sp/>ENUM_MATRIX_OPERATION<sp/>_reduction,<sp/>Matrix&lt;X&gt;*<sp/>_weights<sp/>=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Mean(MATRIX_OPERATION_ABS_DIFF_SQUARE,<sp/>_reduction,<sp/>_prediction,<sp/>_weights);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>logarithmic<sp/>squared<sp/>absolute<sp/>difference<sp/>between<sp/>this<sp/>tensor<sp/>and<sp/>given<sp/>one<sp/>using<sp/>optional<sp/>weights<sp/>tensor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>MeanSquaredLogarithmic(Matrix&lt;X&gt;*<sp/>_prediction,<sp/>ENUM_MATRIX_OPERATION<sp/>_reduction,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>_weights<sp/>=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>Mean(MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG,<sp/>_reduction,<sp/>_prediction,<sp/>_weights);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>mean<sp/>absolute<sp/>using<sp/>given<sp/>reduction<sp/>operation<sp/>and<sp/>optionally,<sp/>weights<sp/>tensor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>MeanReduced(ENUM_MATRIX_OPERATION<sp/>_abs_diff_op,<sp/>ENUM_MATRIX_OPERATION<sp/>_reduction,<sp/>Matrix&lt;X&gt;*<sp/>_prediction,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>_weights<sp/>=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>_diff<sp/>=<sp/>Mean(_abs_diff_op,<sp/>_reduction,<sp/>_prediction,<sp/>_weights);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>result;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(_reduction)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_SUM:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>_diff.Sum();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_MIN:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>_diff.Min();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_MAX:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>_diff.Max();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_AVG:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>_diff.Avg();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_MED:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>_diff.Med();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;MeanAbsolute():<sp/>Unsupported<sp/>reduction<sp/>type:<sp/>&quot;,<sp/>EnumToString(_reduction),<sp/>&quot;!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>MinOf((X)0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delete<sp/>_diff;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>mean<sp/>absolute<sp/>using<sp/>given<sp/>reduction<sp/>operation<sp/>and<sp/>optionally,<sp/>weights<sp/>tensor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>MeanAbsolute(ENUM_MATRIX_OPERATION<sp/>_reduction,<sp/>Matrix&lt;X&gt;*<sp/>_prediction,<sp/>Matrix&lt;X&gt;*<sp/>_weights<sp/>=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>MeanReduced(MATRIX_OPERATION_ABS_DIFF,<sp/>_reduction,<sp/>_prediction,<sp/>_weights);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>squared<sp/>mean<sp/>absolute<sp/>using<sp/>given<sp/>reduction<sp/>operation<sp/>and<sp/>optionally,<sp/>weights<sp/>tensor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>MeanSquared(ENUM_MATRIX_OPERATION<sp/>_reduction,<sp/>Matrix&lt;X&gt;*<sp/>_prediction,<sp/>Matrix&lt;X&gt;*<sp/>_weights<sp/>=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>MeanReduced(MATRIX_OPERATION_ABS_DIFF_SQUARE,<sp/>_reduction,<sp/>_prediction,<sp/>_weights);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Calculates<sp/>logarithmic<sp/>squared<sp/>mean<sp/>absolute<sp/>using<sp/>given<sp/>reduction<sp/>operation<sp/>and<sp/>optionally,<sp/>weights<sp/>tensor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>MeanSquaredLogarithmic(ENUM_MATRIX_OPERATION<sp/>_reduction,<sp/>Matrix&lt;X&gt;*<sp/>_prediction,<sp/>Matrix&lt;X&gt;*<sp/>_weights<sp/>=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>MeanReduced(MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG,<sp/>_reduction,<sp/>_prediction,<sp/>_weights);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>ReLU<sp/>activator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>Relu()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>result<sp/>=<sp/>Clone();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>result.Relu_();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Inplace<sp/>ReLU<sp/>activator.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Relu_()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_out1<sp/>=<sp/>0,<sp/>_out2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_out3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr_first_dimension)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ptr_first_dimension.Op(MATRIX_OPERATION_RELU,<sp/>0,<sp/>0,<sp/>0,<sp/>_out1,<sp/>_out2,<sp/>_out3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Clones<sp/>current<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>Clone()<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>_cloned<sp/>=<sp/>new<sp/>Matrix&lt;X&gt;(dimensions[0],<sp/>dimensions[1],<sp/>dimensions[2],<sp/>dimensions[3],<sp/>dimensions[4]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_cloned.ptr_first_dimension.CopyFrom(ptr_first_dimension);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_cloned;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Sets<sp/>value<sp/>of<sp/>the<sp/>given<sp/>matrix&apos;s<sp/>dimension.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@todo<sp/>Deep<sp/>version<sp/>of<sp/>this<sp/>method.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Set(X<sp/>value,<sp/>const<sp/>int<sp/>_1d,<sp/>const<sp/>int<sp/>_2d<sp/>=<sp/>-1,<sp/>const<sp/>int<sp/>_3d<sp/>=<sp/>-1,<sp/>const<sp/>int<sp/>_4d<sp/>=<sp/>-1,<sp/>const<sp/>int<sp/>_5d<sp/>=<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_2d<sp/>==<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>this[_1d]<sp/>=<sp/>value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(_3d<sp/>==<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>this[_1d][_2d]<sp/>=<sp/>value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(_4d<sp/>==<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>this[_1d][_2d][_3d]<sp/>=<sp/>value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(_5d<sp/>==<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>this[_1d][_2d][_3d][_4d]<sp/>=<sp/>value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>this[_1d][_2d][_3d][_4d][_5d]<sp/>=<sp/>value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>GetConv2d(int<sp/>_in_channels,<sp/>int<sp/>_out_channels,<sp/>int<sp/>_krn_1d,<sp/>int<sp/>_krn_2d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>_stride_1d<sp/>=<sp/>MATRIX_STRIDE_AS_POOL,<sp/>int<sp/>_stride_2d<sp/>=<sp/>MATRIX_STRIDE_AS_POOL,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>_weights<sp/>=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(dimensions[0]<sp/>&lt;<sp/>_in_channels)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Alert(&quot;Insufficient<sp/>number<sp/>of<sp/>channels<sp/>in<sp/>the<sp/>input.<sp/>First<sp/>dimensions<sp/>should<sp/>have<sp/>&quot;,<sp/>_in_channels,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;<sp/>arrays,<sp/>got<sp/>&quot;,<sp/>dimensions[0]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>clone<sp/>=<sp/>Clone();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>clone.DuplicateDimension(1,<sp/>_out_channels<sp/>-<sp/>1);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_weights<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>weight_flattened<sp/>=<sp/>_weights.Flatten();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>_in_channel_idx<sp/>=<sp/>0;<sp/>_in_channel_idx<sp/>&lt;<sp/>_in_channels;<sp/>++_in_channel_idx)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clone.ptr_first_dimension.containers[_in_channel_idx].Op(weight_flattened.ptr_first_dimension,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MATRIX_OPERATION_MULTIPLY);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>delete<sp/>weight_flattened;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;double&gt;*<sp/>pooled<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clone.GetPooled(MATRIX_OPERATION_SUM,<sp/>MATRIX_PADDING_VALID,<sp/>1,<sp/>2,<sp/>_krn_1d,<sp/>_krn_2d,<sp/>0,<sp/><sp/>//<sp/>Kernel<sp/>size.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/>2,<sp/>_stride_1d,<sp/>_stride_2d);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delete<sp/>clone;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>pooled;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>void<sp/>GetPooledSize(ENUM_MATRIX_PADDING<sp/>_padding,<sp/>int<sp/>_dim_1d,<sp/>int<sp/>_dim_2d,<sp/>int<sp/>_dim_3d,<sp/>int<sp/>_dim_4d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>_dim_5d,<sp/>int<sp/>_pool_1d,<sp/>int<sp/>_pool_2d,<sp/>int<sp/>_pool_3d,<sp/>int<sp/>_pool_4d,<sp/>int<sp/>_pool_5d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>_stride_1d,<sp/>int<sp/>_stride_2d,<sp/>int<sp/>_stride_3d,<sp/>int<sp/>_stride_4d,<sp/>int<sp/>_stride_5d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int&amp;<sp/>_out_1d,<sp/>int&amp;<sp/>_out_2d,<sp/>int&amp;<sp/>_out_3d,<sp/>int&amp;<sp/>_out_4d,<sp/>int&amp;<sp/>_out_5d)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Calculating<sp/>resulting<sp/>matrix<sp/>required<sp/>sizes<sp/>per<sp/>dimension.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#define<sp/>_MATRIX_CHECK_POOL_AND_STRIDE(num)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(_pool_##num##d<sp/>==<sp/>0)<sp/>_pool_##num##d<sp/>=<sp/>_dim_##num##d;<sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(_stride_##num##d<sp/>==<sp/>MATRIX_STRIDE_AS_POOL)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_stride_##num##d<sp/>=<sp/>_pool_##num##d;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>else<sp/>if<sp/>(_stride_##num##d<sp/>==<sp/>0)<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_stride_##num##d<sp/>=<sp/>1;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_CHECK_POOL_AND_STRIDE(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_CHECK_POOL_AND_STRIDE(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_CHECK_POOL_AND_STRIDE(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_CHECK_POOL_AND_STRIDE(4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_CHECK_POOL_AND_STRIDE(5);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_padding<sp/>==<sp/>MATRIX_PADDING_VALID)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_out_1d<sp/>=<sp/>_stride_1d<sp/>&gt;<sp/>0<sp/>?<sp/>int(MathCeil(((X)_dim_1d<sp/>-<sp/>_pool_1d<sp/>+<sp/>1)<sp/>/<sp/>_stride_1d))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>0;<sp/><sp/>//<sp/>(3<sp/>-<sp/>z2<sp/>+<sp/>1)<sp/>/<sp/>2<sp/><sp/>=<sp/><sp/>Ceil(1)<sp/><sp/><sp/><sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_out_2d<sp/>=<sp/>_out_1d<sp/>==<sp/>0<sp/>?<sp/>0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>(_stride_2d<sp/>&gt;<sp/>0<sp/>?<sp/>int(MathCeil(((X)_dim_2d<sp/>-<sp/>_pool_2d<sp/>+<sp/>1)<sp/>/<sp/>_stride_2d))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>0);<sp/><sp/>//<sp/>(2<sp/>-<sp/>2<sp/>+<sp/>1)<sp/>/<sp/>2<sp/><sp/>=<sp/><sp/>Ceil(0.5)<sp/><sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_out_3d<sp/>=<sp/>_out_2d<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>(_stride_3d<sp/>&gt;<sp/>0<sp/>?<sp/>int(MathCeil(((X)_dim_3d<sp/>-<sp/>_pool_3d<sp/>+<sp/>1)<sp/>/<sp/>_stride_3d))<sp/>:<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_out_4d<sp/>=<sp/>_out_3d<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>(_stride_4d<sp/>&gt;<sp/>0<sp/>?<sp/>int(MathCeil(((X)_dim_4d<sp/>-<sp/>_pool_4d<sp/>+<sp/>1)<sp/>/<sp/>_stride_4d))<sp/>:<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_out_5d<sp/>=<sp/>_out_4d<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>(_stride_5d<sp/>&gt;<sp/>0<sp/>?<sp/>int(MathCeil(((X)_dim_5d<sp/>-<sp/>_pool_5d<sp/>+<sp/>1)<sp/>/<sp/>_stride_5d))<sp/>:<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_out_1d<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_stride_1d<sp/>&gt;<sp/>0<sp/>?<sp/>int(_stride_1d<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>ceil((X)_dim_1d<sp/>/<sp/>_stride_1d))<sp/>:<sp/>0;<sp/><sp/>//<sp/>3<sp/>/<sp/>2<sp/><sp/>=<sp/><sp/>Ceil(1.5)<sp/><sp/>=<sp/><sp/>2</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_out_2d<sp/>=<sp/>_out_1d<sp/>==<sp/>0<sp/>?<sp/>0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>(_stride_2d<sp/>&gt;<sp/>0<sp/>?<sp/>int(_stride_2d<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>ceil((X)_dim_2d<sp/>/<sp/>_stride_2d))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>0);<sp/><sp/>//<sp/>2<sp/>/<sp/>2<sp/><sp/>=<sp/><sp/>Ceil(1)<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_out_3d<sp/>=<sp/>_out_2d<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>(_stride_3d<sp/>&gt;<sp/>0<sp/>?<sp/>int(_stride_3d<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>ceil((X)_dim_3d<sp/>/<sp/>_stride_3d))<sp/>:<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_out_4d<sp/>=<sp/>_out_3d<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>(_stride_4d<sp/>&gt;<sp/>0<sp/>?<sp/>int(_stride_4d<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>ceil((X)_dim_4d<sp/>/<sp/>_stride_4d))<sp/>:<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_out_5d<sp/>=<sp/>_out_4d<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>(_stride_5d<sp/>&gt;<sp/>0<sp/>?<sp/>int(_stride_5d<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>ceil((X)_dim_5d<sp/>/<sp/>_stride_5d))<sp/>:<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>int<sp/>GetPooledSizeTotal(ENUM_MATRIX_PADDING<sp/>_padding,<sp/>int<sp/>_dim_1d,<sp/>int<sp/>_dim_2d,<sp/>int<sp/>_dim_3d,<sp/>int<sp/>_dim_4d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>_dim_5d,<sp/>int<sp/>_pool_1d,<sp/>int<sp/>_pool_2d,<sp/>int<sp/>_pool_3d,<sp/>int<sp/>_pool_4d,<sp/>int<sp/>_pool_5d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>_stride_1d,<sp/>int<sp/>_stride_2d,<sp/>int<sp/>_stride_3d,<sp/>int<sp/>_stride_4d,<sp/>int<sp/>_stride_5d)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_dimensions[MATRIX_DIMENSIONS];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GetPooledSize(_padding,<sp/>_dim_1d,<sp/>_dim_2d,<sp/>_dim_3d,<sp/>_dim_4d,<sp/>_dim_5d,<sp/>_pool_1d,<sp/>_pool_2d,<sp/>_pool_3d,<sp/>_pool_4d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_pool_5d,<sp/>_stride_1d,<sp/>_stride_2d,<sp/>_stride_3d,<sp/>_stride_4d,<sp/>_stride_5d,<sp/>_dimensions[0],<sp/>_dimensions[1],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_dimensions[2],<sp/>_dimensions[3],<sp/>_dimensions[4]);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>GetDimensionsTotal(_dimensions);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>int<sp/>GetDimensionsTotal(int&amp;<sp/>dimensions[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>size<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(dimensions);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dimensions[i]<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size<sp/>*=<sp/>dimensions[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>matrix<sp/>reduces<sp/>by<sp/>given<sp/>method<sp/>(avg,<sp/>min,<sp/>max)<sp/>using<sp/>pooling.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Stride,<sp/>when<sp/>set<sp/>to<sp/>0,<sp/>will<sp/>revert<sp/>back<sp/>to<sp/>1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>GetPooled(ENUM_MATRIX_OPERATION<sp/>_op,<sp/>ENUM_MATRIX_PADDING<sp/>_padding,<sp/>int<sp/>_pool_1d<sp/>=<sp/>0,<sp/>int<sp/>_pool_2d<sp/>=<sp/>0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>_pool_3d<sp/>=<sp/>0,<sp/>int<sp/>_pool_4d<sp/>=<sp/>0,<sp/>int<sp/>_pool_5d<sp/>=<sp/>0,<sp/>int<sp/>_stride_1d<sp/>=<sp/>MATRIX_STRIDE_AS_POOL,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>_stride_2d<sp/>=<sp/>MATRIX_STRIDE_AS_POOL,<sp/>int<sp/>_stride_3d<sp/>=<sp/>MATRIX_STRIDE_AS_POOL,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>_stride_4d<sp/>=<sp/>MATRIX_STRIDE_AS_POOL,<sp/>int<sp/>_stride_5d<sp/>=<sp/>MATRIX_STRIDE_AS_POOL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_out_1d,<sp/>_out_2d,<sp/>_out_3d,<sp/>_out_4d,<sp/>_out_5d;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#define<sp/>_MATRIX_STRIDE_AS_POOL_MAYBE(dim)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(_stride_##dim##d<sp/>==<sp/>MATRIX_STRIDE_AS_POOL)<sp/>{<sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_stride_##dim##d<sp/>=<sp/>_pool_##dim##d;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_STRIDE_AS_POOL_MAYBE(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_STRIDE_AS_POOL_MAYBE(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_STRIDE_AS_POOL_MAYBE(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_STRIDE_AS_POOL_MAYBE(4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_STRIDE_AS_POOL_MAYBE(5);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GetPooledSize(_padding,<sp/>dimensions[0],<sp/>dimensions[1],<sp/>dimensions[2],<sp/>dimensions[3],<sp/>dimensions[4],<sp/>_pool_1d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_pool_2d,<sp/>_pool_3d,<sp/>_pool_4d,<sp/>_pool_5d,<sp/>_stride_1d,<sp/>_stride_2d,<sp/>_stride_3d,<sp/>_stride_4d,<sp/>_stride_5d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_out_1d,<sp/>_out_2d,<sp/>_out_3d,<sp/>_out_4d,<sp/>_out_5d);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>_result<sp/>=<sp/>new<sp/>Matrix&lt;X&gt;(_out_1d,<sp/>_out_2d,<sp/>_out_3d,<sp/>_out_4d,<sp/>_out_5d);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>If<sp/>limit<sp/>is<sp/>0<sp/>then<sp/>var<sp/>will<sp/>end<sp/>up<sp/>as<sp/>-1<sp/>and<sp/>no<sp/>loop<sp/>will<sp/>be<sp/>performed.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>If<sp/>limit<sp/>is<sp/>not<sp/>0<sp/>then<sp/>normal<sp/>for(var<sp/>=<sp/>0;<sp/>var<sp/>&lt;<sp/>limit;<sp/>++var)<sp/>will<sp/>be<sp/>performed.</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>_MATRIX_FOR_OR_MINUS_1(var,<sp/>limit)<sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>var<sp/>=<sp/>(limit<sp/>==<sp/>0<sp/>?<sp/>-1<sp/>:<sp/>0);<sp/>(limit<sp/>==<sp/>0)<sp/>?<sp/>var<sp/>==<sp/>-1<sp/>:<sp/>var<sp/>&lt;<sp/>limit;<sp/>++var)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_FOR_OR_MINUS_1(_chunk_1d,<sp/>_out_1d)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_FOR_OR_MINUS_1(_chunk_2d,<sp/>_out_2d)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_FOR_OR_MINUS_1(_chunk_3d,<sp/>_out_3d)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_FOR_OR_MINUS_1(_chunk_4d,<sp/>_out_4d)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_FOR_OR_MINUS_1(_chunk_5d,<sp/>_out_5d)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X<sp/>result<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ChunkOp(_op,<sp/>_padding,<sp/>_pool_1d,<sp/>_pool_2d,<sp/>_pool_3d,<sp/>_pool_4d,<sp/>_pool_5d,<sp/>_stride_1d,<sp/>_stride_2d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_stride_3d,<sp/>_stride_4d,<sp/>_stride_5d,<sp/>_chunk_1d,<sp/>_chunk_2d,<sp/>_chunk_3d,<sp/>_chunk_4d,<sp/>_chunk_5d);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_result.Set(result,<sp/>_chunk_1d,<sp/>_chunk_2d,<sp/>_chunk_3d,<sp/>_chunk_4d,<sp/>_chunk_5d);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Performs<sp/>given<sp/>operation<sp/>on<sp/>the<sp/>multidimensional<sp/>data,<sp/>taking<sp/>into<sp/>consideration<sp/>pool/chunk<sp/>size,<sp/>stride<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>paddings<sp/>previously<sp/>calculated<sp/>by<sp/>GetPooled().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X<sp/>ChunkOp(ENUM_MATRIX_OPERATION<sp/>_op,<sp/>ENUM_MATRIX_PADDING<sp/>_padding,<sp/>const<sp/>int<sp/>_pool_1d,<sp/>const<sp/>int<sp/>_pool_2d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int<sp/>_pool_3d,<sp/>const<sp/>int<sp/>_pool_4d,<sp/>const<sp/>int<sp/>_pool_5d,<sp/>const<sp/>int<sp/>_stride_1d,<sp/>const<sp/>int<sp/>_stride_2d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int<sp/>_stride_3d,<sp/>const<sp/>int<sp/>_stride_4d,<sp/>const<sp/>int<sp/>_stride_5d,<sp/>const<sp/>int<sp/>_chunk_1d,<sp/>const<sp/>int<sp/>_chunk_2d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int<sp/>_chunk_3d,<sp/>const<sp/>int<sp/>_chunk_4d,<sp/>const<sp/>int<sp/>_chunk_5d)<sp/>{</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>_MATRIX_FOR_DIM(dim)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>_start_##dim##d<sp/>=<sp/>_chunk_##dim##d<sp/>==<sp/>-1<sp/>?<sp/>0<sp/>:<sp/>(_chunk_##dim##d<sp/>*<sp/>_stride_##dim##d);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>d##dim<sp/>=<sp/>(_chunk_##dim##d<sp/>==<sp/>-1)<sp/>?<sp/>(dimensions[dim<sp/>-<sp/>1]<sp/>!=<sp/>0<sp/>?<sp/>_start_##dim##d<sp/>:<sp/>-1)<sp/>:<sp/>_start_##dim##d;<sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(d##dim<sp/>==<sp/>-1<sp/>||<sp/>d##dim<sp/>&lt;<sp/>_start_##dim##d<sp/>+<sp/>_pool_##dim##d);<sp/>++d##dim)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>value<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MatrixDimensionAccessor&lt;X&gt;<sp/>_accessor_d1,<sp/>_accessor_d2,<sp/>_accessor_d3,<sp/>_accessor_d4,<sp/>_accessor_d5;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#define<sp/>_MATRIX_AGGR(val)<sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>++_count;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>_min<sp/>=<sp/>MathMin(_min,<sp/>val);<sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>_max<sp/>=<sp/>MathMax(_max,<sp/>val);<sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>_sum<sp/>+=<sp/>val;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_min<sp/>=<sp/>MaxOf((X)0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_max<sp/>=<sp/>MinOf((X)0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_sum<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_avg<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_val;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_MATRIX_FOR_DIM(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>_d1_valid<sp/>=<sp/>d1<sp/>&lt;<sp/>dimensions[0]<sp/>&amp;&amp;<sp/>d1<sp/>&gt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!_d1_valid)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>We<sp/>don&apos;t<sp/>aggreate<sp/>zeroes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>First<sp/>dimension<sp/>have<sp/>values?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_accessor_d1<sp/>=<sp/>this[d1];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_accessor_d1.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_AGGR(ptr_first_dimension.values[d1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_FOR_DIM(2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>_d2_valid<sp/>=<sp/>d2<sp/>&lt;<sp/>dimensions[1]<sp/>&amp;&amp;<sp/>d2<sp/>&gt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!_d2_valid)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>We<sp/>don&apos;t<sp/>aggreate<sp/>zeroes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Second<sp/>dimension<sp/>have<sp/>values?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_accessor_d2<sp/>=<sp/>_accessor_d1[d2];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_accessor_d2.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_val<sp/>=<sp/>_accessor_d2.Val();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_AGGR(_val);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_FOR_DIM(3)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>_d3_valid<sp/>=<sp/>d3<sp/>&lt;<sp/>dimensions[2]<sp/>&amp;&amp;<sp/>d3<sp/>&gt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!_d3_valid)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>We<sp/>don&apos;t<sp/>aggreate<sp/>zeroes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Third<sp/>dimension<sp/>have<sp/>values?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_accessor_d3<sp/>=<sp/>_accessor_d2[d3];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_accessor_d3.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_val<sp/>=<sp/>_accessor_d3.Val();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_AGGR(_val);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_FOR_DIM(4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>_d4_valid<sp/>=<sp/>d4<sp/>&lt;<sp/>dimensions[3]<sp/>&amp;&amp;<sp/>d4<sp/>&gt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!_d4_valid)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>We<sp/>don&apos;t<sp/>aggreate<sp/>zeroes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Fourth<sp/>dimension<sp/>have<sp/>values?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_accessor_d4<sp/>=<sp/>_accessor_d3[d4];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_accessor_d4.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_val<sp/>=<sp/>_accessor_d4.Val();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_AGGR(_val);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_FOR_DIM(5)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>_d5_valid<sp/>=<sp/>d5<sp/>&lt;<sp/>dimensions[4]<sp/>&amp;&amp;<sp/>d5<sp/>&gt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!_d5_valid)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>We<sp/>don&apos;t<sp/>aggreate<sp/>zeroes.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Fifth<sp/>dimension<sp/>have<sp/>values?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_accessor_d5<sp/>=<sp/>_accessor_d4[d5];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_accessor_d4.Type()<sp/>==<sp/>MATRIX_DIMENSION_TYPE_VALUES)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_val<sp/>=<sp/>_accessor_d5.Val();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MATRIX_AGGR(_val);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Matrix::ChunkOp():<sp/>Internal<sp/>error.<sp/>5th<sp/>dimension<sp/>shouldn&apos;t<sp/>have<sp/>containers!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_avg<sp/>=<sp/>_sum<sp/>/<sp/>_count;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(_op)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_MIN:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_min;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_MAX:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_max;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_SUM:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_sum;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>MATRIX_OPERATION_AVG:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>_avg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Matrix::ChunkOp():<sp/>Invalid<sp/>operation<sp/>&quot;,<sp/>EnumToString(_op),<sp/>&quot;!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Checks<sp/>whether<sp/>both<sp/>matrices<sp/>have<sp/>the<sp/>same<sp/>dimensions&apos;<sp/>length.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>bool<sp/>ShapeCompatible(Matrix&lt;X&gt;*<sp/>_a,<sp/>Matrix&lt;X&gt;*<sp/>_b)<sp/>{<sp/>return<sp/>_a.Repr()<sp/>==<sp/>_b.Repr();<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Checks<sp/>whether<sp/>right<sp/>matrix<sp/>have<sp/>less<sp/>or<sp/>equal<sp/>dimensions&apos;<sp/>length..</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>bool<sp/>ShapeCompatibleLossely(Matrix&lt;X&gt;*<sp/>_a,<sp/>Matrix&lt;X&gt;*<sp/>_b)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_b.GetDimensions()<sp/>&gt;<sp/>_a.GetDimensions())<sp/>return<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>_b.GetDimensions();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_b.dimensions[i]<sp/>!=<sp/>1<sp/>&amp;&amp;<sp/>_b.dimensions[i]<sp/>&gt;<sp/>_a.dimensions[i])<sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>Matrix&lt;X&gt;*<sp/>CreateFromString(string<sp/>text)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>_ptr_matrix<sp/>=<sp/>new<sp/>Matrix&lt;X&gt;();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_ptr_matrix.FromString(text);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_ptr_matrix;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FromString(string<sp/>text)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MatrixDimension&lt;X&gt;*_dimensions[],<sp/>*_root_dimension<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>_dimensions_length[MATRIX_DIMENSIONS]<sp/>=<sp/>{0,<sp/>0,<sp/>0,<sp/>0,<sp/>0};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>i,<sp/>_number_start_pos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>_had_values;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>X<sp/>_number;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>_expecting_value_or_child<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>_expecting_comma<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>_expecting_end<sp/>=<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>StringLen(text);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>unsigned<sp/>short<sp/>_char<sp/>=<sp/>StringGetCharacter(text,<sp/>i),<sp/>c;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(_char)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;[&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!_expecting_value_or_child)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Unexpected<sp/>&apos;[&apos;<sp/>at<sp/>offset<sp/>&quot;,<sp/>i,<sp/>&quot;!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_had_values<sp/>=<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(ArraySize(_dimensions)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_dimensions[ArraySize(_dimensions)<sp/>-<sp/>1].type<sp/>=<sp/>MATRIX_DIMENSION_TYPE_CONTAINERS;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ArrayResize(_dimensions,<sp/>ArraySize(_dimensions)<sp/>+<sp/>1,<sp/>MATRIX_DIMENSIONS);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_dimensions[ArraySize(_dimensions)<sp/>-<sp/>1]<sp/>=<sp/>new<sp/>MatrixDimension&lt;X&gt;();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(ArraySize(_dimensions)<sp/>&gt;=<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_dimensions[ArraySize(_dimensions)<sp/>-<sp/>2].AddContainer(_dimensions[ArraySize(_dimensions)<sp/>-<sp/>1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_root_dimension<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_root_dimension<sp/>=<sp/>_dimensions[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_expecting_value_or_child<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_expecting_end<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;]&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ArrayResize(_dimensions,<sp/>ArraySize(_dimensions)<sp/>-<sp/>1,<sp/>MATRIX_DIMENSIONS);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_expecting_value_or_child<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_expecting_comma<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;0&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;1&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;2&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;3&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;4&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;5&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;6&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;7&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;8&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;9&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;-&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;.&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!_expecting_value_or_child)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Print(&quot;Unexpected<sp/>number<sp/>at<sp/>offset<sp/>&quot;,<sp/>i,<sp/>&quot;!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Parsing<sp/>number.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_number_start_pos<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c<sp/>=<sp/>StringGetCharacter(text,<sp/>i++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>while<sp/>((c<sp/>&gt;=<sp/>&apos;0&apos;<sp/>&amp;&amp;<sp/>c<sp/>&lt;=<sp/>&apos;9&apos;)<sp/>||<sp/>c<sp/>==<sp/>&apos;.&apos;<sp/>||<sp/>c<sp/>==<sp/>&apos;-&apos;<sp/>||<sp/>c<sp/>==<sp/>&apos;e&apos;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_number<sp/>=<sp/>(X)StringToDouble(StringSubstr(text,<sp/>_number_start_pos,<sp/>i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>-=<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_dimensions[ArraySize(_dimensions)<sp/>-<sp/>1].type<sp/>=<sp/>MATRIX_DIMENSION_TYPE_VALUES;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_dimensions[ArraySize(_dimensions)<sp/>-<sp/>1].AddValue(_number);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_expecting_end<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_expecting_value_or_child<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_expecting_comma<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;,&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_expecting_value_or_child<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_expecting_comma<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_expecting_end<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;<sp/>&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;\t&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;\r&apos;:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Initialize(_root_dimension);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>string<sp/>or<sp/>human-readable<sp/>representation<sp/>of<sp/>the<sp/>matrix&apos;s<sp/>values.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>[</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/><sp/><sp/>[2,<sp/><sp/>3,<sp/><sp/>4]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[2,<sp/>5]<sp/>[6,<sp/>7]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[5,<sp/><sp/>6,<sp/><sp/>7]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[8,<sp/><sp/>9,<sp/>10]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>string<sp/>ToString(bool<sp/>_whitespaces<sp/>=<sp/>false,<sp/>int<sp/>_precision<sp/>=<sp/>3)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>ptr_first_dimension.ToString(_whitespaces,<sp/>_precision);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>representation<sp/>of<sp/>matrix&apos;s<sp/>dimension,<sp/>e.g.,<sp/>&quot;[2,<sp/>5,<sp/>10]&quot;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>string<sp/>Repr()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>string<sp/>_out<sp/>=<sp/>&quot;[&quot;;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ArraySize(dimensions);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dimensions[i]<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_out<sp/>+=<sp/>IntegerToString(dimensions[i])<sp/>+<sp/>((i<sp/>&lt;<sp/>MATRIX_DIMENSIONS<sp/>&amp;&amp;<sp/>dimensions[i<sp/>+<sp/>1]<sp/>!=<sp/>0)<sp/>?<sp/>&quot;,<sp/>&quot;<sp/>:<sp/>&quot;&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>_out<sp/>+<sp/>&quot;]&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
    </programlisting>
    <location file="Matrix.mqh"/>
  </compounddef>
</doxygen>
