<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="_dict_8mqh" kind="file" language="C++">
    <compoundname>Dict.mqh</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">//+------------------------------------------------------------------+</highlight></codeline>
<codeline><highlight class="normal">//|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EA31337<sp/>framework<sp/>|</highlight></codeline>
<codeline><highlight class="normal">//|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Copyright<sp/>2016-2021,<sp/>31337<sp/>Investments<sp/>Ltd<sp/>|</highlight></codeline>
<codeline><highlight class="normal">//|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>https://github.com/EA31337<sp/>|</highlight></codeline>
<codeline><highlight class="normal">//+------------------------------------------------------------------+</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>This<sp/>file<sp/>is<sp/>free<sp/>software:<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or<sp/>modify</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>it<sp/>under<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>as<sp/>published<sp/>by</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>the<sp/>Free<sp/>Software<sp/>Foundation,<sp/>either<sp/>version<sp/>3<sp/>of<sp/>the<sp/>License,<sp/>or</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>(at<sp/>your<sp/>option)<sp/>any<sp/>later<sp/>version.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>This<sp/>program<sp/>is<sp/>distributed<sp/>in<sp/>the<sp/>hope<sp/>that<sp/>it<sp/>will<sp/>be<sp/>useful,</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>but<sp/>WITHOUT<sp/>ANY<sp/>WARRANTY;<sp/>without<sp/>even<sp/>the<sp/>implied<sp/>warranty<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>MERCHANTABILITY<sp/>or<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE.<sp/><sp/>See<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>You<sp/>should<sp/>have<sp/>received<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>along<sp/>with<sp/>this<sp/>program.<sp/><sp/>If<sp/>not,<sp/>see<sp/>&lt;http://www.gnu.org/licenses/&gt;.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Prevents<sp/>processing<sp/>this<sp/>includes<sp/>file<sp/>for<sp/>the<sp/>second<sp/>time.</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>DICT_MQH</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>DICT_MQH</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;Convert.mqh&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;DictBase.mqh&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;Matrix.mqh&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>K,<sp/>typename<sp/>V&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>DictIterator<sp/>:<sp/>public<sp/>DictIteratorBase&lt;K,<sp/>V&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DictIterator()<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DictIterator(DictBase&lt;K,<sp/>V&gt;&amp;<sp/>dict,<sp/>unsigned<sp/>int<sp/>slotIdx)<sp/>:<sp/>DictIteratorBase(dict,<sp/>slotIdx)<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Copy<sp/>constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DictIterator(const<sp/>DictIterator&amp;<sp/>right)<sp/>:<sp/>DictIteratorBase(right)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Hash-table<sp/>based<sp/>dictionary.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>K,<sp/>typename<sp/>V&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>Dict<sp/>:<sp/>public<sp/>DictBase&lt;K,<sp/>V&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dict()<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dict(string<sp/>_data,<sp/>string<sp/>_dlm<sp/>=<sp/>&quot;\n&quot;)<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Copy<sp/>constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dict(const<sp/>Dict&lt;K,<sp/>V&gt;&amp;<sp/>right)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Resize(right.GetSlotCount());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(unsigned<sp/>int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>(unsigned<sp/>int)ArraySize(right._DictSlots_ref.DictSlots);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_DictSlots_ref.DictSlots[i]<sp/>=<sp/>right._DictSlots_ref.DictSlots[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_DictSlots_ref._num_used<sp/>=<sp/>right._DictSlots_ref._num_used;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_current_id<sp/>=<sp/>right._current_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_mode<sp/>=<sp/>right._mode;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>operator=(const<sp/>Dict&lt;K,<sp/>V&gt;&amp;<sp/>right)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Resize(right.GetSlotCount());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(unsigned<sp/>int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>(unsigned<sp/>int)ArraySize(right._DictSlots_ref.DictSlots);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_DictSlots_ref.DictSlots[i]<sp/>=<sp/>right._DictSlots_ref.DictSlots[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_DictSlots_ref._num_used<sp/>=<sp/>right._DictSlots_ref._num_used;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_current_id<sp/>=<sp/>right._current_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_mode<sp/>=<sp/>right._mode;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Clear()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(unsigned<sp/>int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>(unsigned<sp/>int)ArraySize(_DictSlots_ref.DictSlots);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_DictSlots_ref.DictSlots[i].IsUsed())<sp/>_DictSlots_ref.DictSlots[i].SetFlags(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_DictSlots_ref._num_used<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Inserts<sp/>value<sp/>using<sp/>hashless<sp/>key.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>Push(V<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!InsertInto(_DictSlots_ref,<sp/>value))<sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Inserts<sp/>value<sp/>using<sp/>hashless<sp/>key.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>operator+=(V<sp/>value)<sp/>{<sp/>return<sp/>Push(value);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Inserts<sp/>or<sp/>replaces<sp/>value<sp/>for<sp/>a<sp/>given<sp/>key.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>Set(K<sp/>key,<sp/>V<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!InsertInto(_DictSlots_ref,<sp/>key,<sp/>value))<sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>V<sp/>operator[](K<sp/>key)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_mode<sp/>==<sp/>DictModeList)<sp/>return<sp/>GetSlot((unsigned<sp/>int)key).value;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>position;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DictSlot&lt;K,<sp/>V&gt;*<sp/>slot<sp/>=<sp/>GetSlotByKey(_DictSlots_ref,<sp/>key,<sp/>position);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!slot)<sp/>return<sp/>(V)NULL;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>slot.value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>value<sp/>for<sp/>a<sp/>given<sp/>key.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>V<sp/>GetByKey(const<sp/>K<sp/>_key,<sp/>V<sp/>_default<sp/>=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>position;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DictSlot&lt;K,<sp/>V&gt;*<sp/>slot<sp/>=<sp/>GetSlotByKey(_DictSlots_ref,<sp/>_key,<sp/>position);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!slot)<sp/>return<sp/>_default;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>slot.value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Checks<sp/>whether<sp/>dictionary<sp/>contains<sp/>given<sp/>key<sp/>=&gt;<sp/>value<sp/>pair.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>Contains(const<sp/>K<sp/>key,<sp/>const<sp/>V<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>position;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DictSlot&lt;K,<sp/>V&gt;*<sp/>slot<sp/>=<sp/>GetSlotByKey(_DictSlots_ref,<sp/>key,<sp/>position);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!slot)<sp/>return<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>slot.value<sp/>==<sp/>value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Inserts<sp/>value<sp/>into<sp/>given<sp/>array<sp/>of<sp/>DictSlots.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>InsertInto(DictSlotsRef&lt;K,<sp/>V&gt;&amp;<sp/>dictSlotsRef,<sp/>const<sp/>K<sp/>key,<sp/>V<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_mode<sp/>==<sp/>DictModeUnknown)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_mode<sp/>=<sp/>DictModeDict;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(_mode<sp/>!=<sp/>DictModeDict)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Alert(&quot;Warning:<sp/>Dict<sp/>already<sp/>operates<sp/>as<sp/>a<sp/>list,<sp/>not<sp/>a<sp/>dictionary!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>position;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DictSlot&lt;K,<sp/>V&gt;*<sp/>keySlot<sp/>=<sp/>GetSlotByKey(dictSlotsRef,<sp/>key,<sp/>position);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(keySlot<sp/>==<sp/>NULL<sp/>&amp;&amp;<sp/>dictSlotsRef._num_used<sp/>==<sp/>ArraySize(dictSlotsRef.DictSlots))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>No<sp/>DictSlotsRef.DictSlots<sp/>available,<sp/>we<sp/>need<sp/>to<sp/>expand<sp/>array<sp/>of<sp/>DictSlotsRef.DictSlots<sp/>(by<sp/>25%).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!Resize(MathMax(10,<sp/>(int)((float)ArraySize(dictSlotsRef.DictSlots)<sp/>*<sp/>1.25))))<sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(keySlot<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>position<sp/>=<sp/>Hash(key)<sp/>%<sp/>ArraySize(dictSlotsRef.DictSlots);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Searching<sp/>for<sp/>empty<sp/>DictSlot&lt;K,<sp/>V&gt;<sp/>or<sp/>used<sp/>one<sp/>with<sp/>the<sp/>matching<sp/>key.<sp/>It<sp/>skips<sp/>used,<sp/>hashless<sp/>DictSlots.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(dictSlotsRef.DictSlots[position].IsUsed()<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(!dictSlotsRef.DictSlots[position].HasKey()<sp/>||<sp/>dictSlotsRef.DictSlots[position].key<sp/>!=<sp/>key))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Position<sp/>may<sp/>overflow,<sp/>so<sp/>we<sp/>will<sp/>start<sp/>from<sp/>the<sp/>beginning.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>position<sp/>=<sp/>(position<sp/>+<sp/>1)<sp/>%<sp/>ArraySize(dictSlotsRef.DictSlots);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>++dictSlotsRef._num_used;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dictSlotsRef.DictSlots[position].key<sp/>=<sp/>key;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dictSlotsRef.DictSlots[position].value<sp/>=<sp/>value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dictSlotsRef.DictSlots[position].SetFlags(DICT_SLOT_HAS_KEY<sp/>|<sp/>DICT_SLOT_IS_USED<sp/>|<sp/>DICT_SLOT_WAS_USED);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Inserts<sp/>hashless<sp/>value<sp/>into<sp/>given<sp/>array<sp/>of<sp/>DictSlots.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>InsertInto(DictSlotsRef&lt;K,<sp/>V&gt;&amp;<sp/>dictSlotsRef,<sp/>V<sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(_mode<sp/>==<sp/>DictModeUnknown)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_mode<sp/>=<sp/>DictModeList;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(_mode<sp/>!=<sp/>DictModeList)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Alert(&quot;Warning:<sp/>Dict<sp/>already<sp/>operates<sp/>as<sp/>a<sp/>dictionary,<sp/>not<sp/>a<sp/>list!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(dictSlotsRef._num_used<sp/>==<sp/>ArraySize(dictSlotsRef.DictSlots))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>No<sp/>DictSlotsRef.DictSlots<sp/>available,<sp/>we<sp/>need<sp/>to<sp/>expand<sp/>array<sp/>of<sp/>DictSlotsRef.DictSlots<sp/>(by<sp/>25%).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!Resize(MathMax(10,<sp/>(int)((float)ArraySize(dictSlotsRef.DictSlots)<sp/>*<sp/>1.25))))<sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>position<sp/>=<sp/>Hash((unsigned<sp/>int)dictSlotsRef._list_index)<sp/>%<sp/>ArraySize(dictSlotsRef.DictSlots);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Searching<sp/>for<sp/>empty<sp/>DictSlot&lt;K,<sp/>V&gt;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(dictSlotsRef.DictSlots[position].IsUsed())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Position<sp/>may<sp/>overflow,<sp/>so<sp/>we<sp/>will<sp/>start<sp/>from<sp/>the<sp/>beginning.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>position<sp/>=<sp/>(position<sp/>+<sp/>1)<sp/>%<sp/>ArraySize(dictSlotsRef.DictSlots);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dictSlotsRef.DictSlots[position].value<sp/>=<sp/>value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dictSlotsRef.DictSlots[position].SetFlags(DICT_SLOT_IS_USED<sp/>|<sp/>DICT_SLOT_WAS_USED);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++dictSlotsRef._list_index;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++dictSlotsRef._num_used;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Shrinks<sp/>or<sp/>expands<sp/>array<sp/>of<sp/>DictSlots.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>Resize(unsigned<sp/>int<sp/>new_size)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(new_size<sp/>&lt;=<sp/>MathMin(_DictSlots_ref._num_used,<sp/>ArraySize(_DictSlots_ref.DictSlots)))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>We<sp/>already<sp/>use<sp/>minimum<sp/>number<sp/>of<sp/>slots<sp/>possible.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DictSlotsRef&lt;K,<sp/>V&gt;<sp/>new_DictSlots;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ArrayResize(new_DictSlots.DictSlots,<sp/>new_size)<sp/>==<sp/>-1)<sp/>return<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>i;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>new_size;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>new_DictSlots.DictSlots[i].SetFlags(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>new_DictSlots._num_used<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Copies<sp/>entire<sp/>array<sp/>of<sp/>DictSlots<sp/>into<sp/>new<sp/>array<sp/>of<sp/>DictSlots.<sp/>Hashes<sp/>will<sp/>be<sp/>rehashed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>(unsigned<sp/>int)ArraySize(_DictSlots_ref.DictSlots);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!_DictSlots_ref.DictSlots[i].IsUsed())<sp/>continue;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_DictSlots_ref.DictSlots[i].HasKey())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!InsertInto(new_DictSlots,<sp/>_DictSlots_ref.DictSlots[i].key,<sp/>_DictSlots_ref.DictSlots[i].value))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!InsertInto(new_DictSlots,<sp/>_DictSlots_ref.DictSlots[i].value))<sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Freeing<sp/>old<sp/>DictSlots<sp/>array.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ArrayFree(_DictSlots_ref.DictSlots);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_DictSlots_ref<sp/>=<sp/>new_DictSlots;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SerializerNodeType<sp/>Serialize(Serializer&amp;<sp/>s)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(s.IsWriting())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(DictIteratorBase&lt;K,<sp/>V&gt;<sp/>i<sp/>=<sp/>Begin();<sp/>i.IsValid();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>V<sp/>value<sp/>=<sp/>i.Value();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s.Pass(this,<sp/>GetMode()<sp/>==<sp/>DictModeDict<sp/>?<sp/>i.KeyAsString()<sp/>:<sp/>&quot;&quot;,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(GetMode()<sp/>==<sp/>DictModeDict)<sp/>?<sp/>SerializerNodeObject<sp/>:<sp/>SerializerNodeArray;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>SerializerIterator&lt;V&gt;<sp/>i;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>s.Begin&lt;V&gt;();<sp/>i.IsValid();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i.HasKey())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Converting<sp/>key<sp/>to<sp/>a<sp/>string.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K<sp/>key;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Convert::StringToType(i.Key(),<sp/>key);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Note<sp/>that<sp/>we&apos;re<sp/>retrieving<sp/>value<sp/>by<sp/>a<sp/>key<sp/>(as<sp/>we<sp/>are<sp/>in<sp/>an</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>object!).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Set(key,<sp/>i.Value(i.Key()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Push(i.Value());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>i.ParentNodeType();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Initializes<sp/>object<sp/>with<sp/>given<sp/>number<sp/>of<sp/>elements.<sp/>Could<sp/>be<sp/>skipped<sp/>for<sp/>non-containers.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>SerializeStub(int<sp/>_n1<sp/>=<sp/>1,<sp/>int<sp/>_n2<sp/>=<sp/>1,<sp/>int<sp/>_n3<sp/>=<sp/>1,<sp/>int<sp/>_n4<sp/>=<sp/>1,<sp/>int<sp/>_n5<sp/>=<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>V<sp/>_child<sp/>=<sp/>(V)<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(_n1--<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Push(_child);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Converts<sp/>values<sp/>into<sp/>1D<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;typename<sp/>X&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Matrix&lt;X&gt;*<sp/>ToMatrix()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Matrix&lt;X&gt;*<sp/>result<sp/>=<sp/>new<sp/>Matrix&lt;X&gt;(Size());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(DictIterator&lt;K,<sp/>V&gt;<sp/>i<sp/>=<sp/>Begin();<sp/>i.IsValid();<sp/>++i)<sp/>result[i.Index()]<sp/>=<sp/>(X)i.Value();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
    </programlisting>
    <location file="Dict.mqh"/>
  </compounddef>
</doxygen>
