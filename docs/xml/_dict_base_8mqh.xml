<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="_dict_base_8mqh" kind="file" language="C++">
    <compoundname>DictBase.mqh</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">//+------------------------------------------------------------------+</highlight></codeline>
<codeline><highlight class="normal">//|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EA31337<sp/>framework<sp/>|</highlight></codeline>
<codeline><highlight class="normal">//|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Copyright<sp/>2016-2021,<sp/>31337<sp/>Investments<sp/>Ltd<sp/>|</highlight></codeline>
<codeline><highlight class="normal">//|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>https://github.com/EA31337<sp/>|</highlight></codeline>
<codeline><highlight class="normal">//+------------------------------------------------------------------+</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>This<sp/>file<sp/>is<sp/>free<sp/>software:<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or<sp/>modify</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>it<sp/>under<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>as<sp/>published<sp/>by</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>the<sp/>Free<sp/>Software<sp/>Foundation,<sp/>either<sp/>version<sp/>3<sp/>of<sp/>the<sp/>License,<sp/>or</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>(at<sp/>your<sp/>option)<sp/>any<sp/>later<sp/>version.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>This<sp/>program<sp/>is<sp/>distributed<sp/>in<sp/>the<sp/>hope<sp/>that<sp/>it<sp/>will<sp/>be<sp/>useful,</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>but<sp/>WITHOUT<sp/>ANY<sp/>WARRANTY;<sp/>without<sp/>even<sp/>the<sp/>implied<sp/>warranty<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>MERCHANTABILITY<sp/>or<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE.<sp/><sp/>See<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>You<sp/>should<sp/>have<sp/>received<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>along<sp/>with<sp/>this<sp/>program.<sp/><sp/>If<sp/>not,<sp/>see<sp/>&lt;http://www.gnu.org/licenses/&gt;.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Prevents<sp/>processing<sp/>this<sp/>includes<sp/>file<sp/>for<sp/>the<sp/>second<sp/>time.</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>DICT_BASE_MQH</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>DICT_BASE_MQH</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Includes.</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;Convert.mqh&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;DictIteratorBase.mqh&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;DictSlot.mqh&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;Serializer.mqh&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Whether<sp/>Dict<sp/>operates<sp/>in<sp/>yet<sp/>uknown<sp/>mode,<sp/>as<sp/>dict<sp/>or<sp/>as<sp/>list.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">enum<sp/>DictMode<sp/>{<sp/>DictModeUnknown,<sp/>DictModeDict,<sp/>DictModeList<sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Hash-table<sp/>based<sp/>dictionary.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>K,<sp/>typename<sp/>V&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>DictBase<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>_hash;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Incremental<sp/>id<sp/>used<sp/>by<sp/>Push()<sp/>method.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>_current_id;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Whether<sp/>Dict<sp/>operates<sp/>in<sp/>yet<sp/>uknown<sp/>mode,<sp/>as<sp/>dict<sp/>or<sp/>as<sp/>list.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DictMode<sp/>_mode;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ref&lt;Log&gt;<sp/>_logger;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DictBase()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_hash<sp/>=<sp/>rand();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_current_id<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_mode<sp/>=<sp/>DictModeUnknown;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Destructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>~DictBase()<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>logger<sp/>object.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Log*<sp/>Logger()<sp/>{<sp/>return<sp/>_logger.Ptr();<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>DictIteratorBase&lt;K,<sp/>V&gt;<sp/>Begin()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Searching<sp/>for<sp/>first<sp/>item<sp/>index.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(unsigned<sp/>int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>(unsigned<sp/>int)ArraySize(_DictSlots_ref.DictSlots);<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_DictSlots_ref.DictSlots[i].IsValid()<sp/>&amp;&amp;<sp/>_DictSlots_ref.DictSlots[i].IsUsed())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DictIteratorBase&lt;K,<sp/>V&gt;<sp/>iter(this,<sp/>i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iter;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>No<sp/>items<sp/>found.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DictIteratorBase&lt;K,<sp/>V&gt;<sp/>invalid;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>invalid;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>unsigned<sp/>int<sp/>GetSlotCount()<sp/>const<sp/>{<sp/>return<sp/>ArraySize(_DictSlots_ref.DictSlots);<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>DictSlot&lt;K,<sp/>V&gt;*<sp/>GetSlot(const<sp/>unsigned<sp/>int<sp/>index)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(index<sp/>&gt;=<sp/>GetSlotCount())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Index<sp/>of<sp/>out<sp/>bounds.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>&amp;_DictSlots_ref.DictSlots[index];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>slot<sp/>by<sp/>key.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DictSlot&lt;K,<sp/>V&gt;*<sp/>GetSlotByKey(DictSlotsRef&lt;K,<sp/>V&gt;&amp;<sp/>dictSlotsRef,<sp/>const<sp/>K<sp/>_key,<sp/>unsigned<sp/>int&amp;<sp/>position)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>numSlots<sp/>=<sp/>ArraySize(dictSlotsRef.DictSlots);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(numSlots<sp/>==<sp/>0)<sp/>return<sp/>NULL;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>position<sp/>=<sp/>Hash(_key)<sp/>%<sp/>numSlots;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>tries_left<sp/>=<sp/>numSlots;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(tries_left--<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dictSlotsRef.DictSlots[position].WasUsed()<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>We<sp/>stop<sp/>searching<sp/>now.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dictSlotsRef.DictSlots[position].IsUsed()<sp/>&amp;&amp;<sp/>dictSlotsRef.DictSlots[position].HasKey()<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dictSlotsRef.DictSlots[position].key<sp/>==<sp/>_key)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>_key<sp/>matches,<sp/>returing<sp/>value<sp/>from<sp/>the<sp/>DictSlot.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>&amp;dictSlotsRef.DictSlots[position];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Position<sp/>may<sp/>overflow,<sp/>so<sp/>we<sp/>will<sp/>start<sp/>from<sp/>the<sp/>beginning.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>position<sp/>=<sp/>(position<sp/>+<sp/>1)<sp/>%<sp/>ArraySize(dictSlotsRef.DictSlots);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>slot<sp/>by<sp/>position.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DictSlot&lt;K,<sp/>V&gt;*<sp/>GetSlotByPos(DictSlotsRef&lt;K,<sp/>V&gt;&amp;<sp/>dictSlotsRef,<sp/>const<sp/>unsigned<sp/>int<sp/>position)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>dictSlotsRef.DictSlots[position].IsUsed()<sp/>?<sp/>&amp;dictSlotsRef.DictSlots[position]<sp/>:<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>hash<sp/>currently<sp/>used<sp/>by<sp/>Dict.<sp/>It<sp/>is<sp/>used<sp/>to<sp/>invalidate<sp/>iterators<sp/>after<sp/>Resize().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>GetHash()<sp/>{<sp/>return<sp/>_hash;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>GetMode()<sp/>{<sp/>return<sp/>_mode;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Removes<sp/>value<sp/>from<sp/>the<sp/>dictionary<sp/>by<sp/>the<sp/>given<sp/>key<sp/>(if<sp/>exists).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Unset(const<sp/>K<sp/>key)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ArraySize(_DictSlots_ref.DictSlots)<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Nothing<sp/>to<sp/>unset.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>position<sp/>=<sp/>Hash(key)<sp/>%<sp/>ArraySize(_DictSlots_ref.DictSlots);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>tries_left<sp/>=<sp/>ArraySize(_DictSlots_ref.DictSlots);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(tries_left--<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_DictSlots_ref.DictSlots[position].WasUsed()<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>We<sp/>stop<sp/>searching<sp/>now.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_DictSlots_ref.DictSlots[position].IsUsed()<sp/>&amp;&amp;<sp/>_DictSlots_ref.DictSlots[position].HasKey()<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_DictSlots_ref.DictSlots[position].key<sp/>==<sp/>key)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Key<sp/>perfectly<sp/>matches,<sp/>it<sp/>indicates<sp/>key<sp/>exists<sp/>in<sp/>the<sp/>dictionary.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_DictSlots_ref.DictSlots[position].RemoveFlags(DICT_SLOT_IS_USED);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--_DictSlots_ref._num_used;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Position<sp/>may<sp/>overflow,<sp/>so<sp/>we<sp/>will<sp/>start<sp/>from<sp/>the<sp/>beginning.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>position<sp/>=<sp/>(position<sp/>+<sp/>1)<sp/>%<sp/>ArraySize(_DictSlots_ref.DictSlots);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>No<sp/>key<sp/>found.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Returns<sp/>number<sp/>of<sp/>used<sp/>DictSlots.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>Size()<sp/>{<sp/>return<sp/>_DictSlots_ref._num_used;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Checks<sp/>whether<sp/>given<sp/>key<sp/>exists<sp/>in<sp/>the<sp/>dictionary.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>KeyExists(const<sp/>K<sp/>key,<sp/>unsigned<sp/>int&amp;<sp/>position)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>numSlots<sp/>=<sp/>ArraySize(_DictSlots_ref.DictSlots);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(numSlots<sp/>==<sp/>0)<sp/>return<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>position<sp/>=<sp/>Hash(key)<sp/>%<sp/>numSlots;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>tries_left<sp/>=<sp/>numSlots;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(tries_left--<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_DictSlots_ref.DictSlots[position].WasUsed()<sp/>==<sp/>false)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>We<sp/>stop<sp/>searching<sp/>now.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(_DictSlots_ref.DictSlots[position].IsUsed()<sp/>&amp;&amp;<sp/>_DictSlots_ref.DictSlots[position].HasKey()<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_DictSlots_ref.DictSlots[position].key<sp/>==<sp/>key)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Key<sp/>perfectly<sp/>matches,<sp/>it<sp/>indicates<sp/>key<sp/>exists<sp/>in<sp/>the<sp/>dictionary.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Position<sp/>may<sp/>overflow,<sp/>so<sp/>we<sp/>will<sp/>start<sp/>from<sp/>the<sp/>beginning.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>position<sp/>=<sp/>(position<sp/>+<sp/>1)<sp/>%<sp/>numSlots;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>No<sp/>key<sp/>found.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>KeyExists(const<sp/>K<sp/>key)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>position;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>KeyExists(key,<sp/>position);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Array<sp/>of<sp/>DictSlots.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DictSlotsRef&lt;K,<sp/>V&gt;<sp/>_DictSlots_ref;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/*<sp/>Hash<sp/>methods<sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Specialization<sp/>of<sp/>hashing<sp/>function.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;typename<sp/>X&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>Hash(X<sp/>x)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(int)x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Specialization<sp/>of<sp/>hashing<sp/>function.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>Hash(datetime<sp/>x)<sp/>{<sp/>return<sp/>(int)x;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Specialization<sp/>of<sp/>hashing<sp/>function.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>Hash(const<sp/>string&amp;<sp/>x)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>char<sp/>c[];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>h<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(x<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>h<sp/>=<sp/>5381;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>n<sp/>=<sp/>StringToCharArray(x,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h<sp/>=<sp/>((h<sp/>&lt;&lt;<sp/>5)<sp/>+<sp/>h)<sp/>+<sp/>c[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>h;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Specialization<sp/>of<sp/>hashing<sp/>function.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>Hash(unsigned<sp/>int<sp/>x)<sp/>{<sp/>return<sp/>x;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Specialization<sp/>of<sp/>hashing<sp/>function.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>Hash(int<sp/>x)<sp/>{<sp/>return<sp/>(unsigned<sp/>int)x;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Specialization<sp/>of<sp/>hashing<sp/>function.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>Hash(float<sp/>x)<sp/>{<sp/>return<sp/>(unsigned<sp/>int)((unsigned<sp/>long)x<sp/>*<sp/>10000<sp/>%<sp/>10000);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
    </programlisting>
    <location file="DictBase.mqh"/>
  </compounddef>
</doxygen>
